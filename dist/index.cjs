"use strict";Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});const a=require("nostr-tools/pure"),D=require("nostr-tools/nip04"),v=require("nostr-tools/pool"),q=require("nostr-tools/nip19"),K=require("@noble/hashes/utils"),B=require("events");function O(t){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(t){for(const r in t)if(r!=="default"){const s=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(e,r,s.get?s:{enumerable:!0,get:()=>t[r]})}}return e.default=t,Object.freeze(e)}const g=O(D),S=O(q);function _(t){return typeof t=="string"&&t.startsWith("nsec1")}function U(t){return typeof t=="string"&&t.startsWith("npub1")}function $(t){if(!_(t))throw new Error("Invalid nsec key");return S.decode(t).data}function x(t){if(t instanceof Uint8Array)return t;if(Buffer.isBuffer(t))return Uint8Array.from(t);if(typeof t=="string"){if(_(t))return $(t);if(H(t))return K.hexToBytes(t)}throw new Error("Unsupported secret key format")}function C(t){const e=x(t);return K.bytesToHex(e)}function R(t){const e=x(t);return S.nsecEncode(e)}function W(t){const e=x(t);return a.getPublicKey(e)}function M(t){if(!U(t))throw new Error("Invalid npub key");return S.decode(t).data.toLowerCase()}function A(t){const e=N(t);return S.npubEncode(e)}function N(t){if(t instanceof Uint8Array)return K.bytesToHex(t);if(Buffer.isBuffer(t))return Buffer.from(t).toString("hex");if(typeof t=="string"){if(U(t))return M(t);if(H(t))return t.toLowerCase()}throw new Error("Unsupported public key format")}function H(t){return typeof t=="string"&&/^[0-9a-fA-F]{64}$/.test(t)}const d={isNsecKey:_,isNpubKey:U,decodeNsecToBytes:$,normalizeSecretKey:x,secretToHex:C,encodeSecretToNsec:R,derivePubkeyFromSecret:W,decodeNpubToHex:M,encodePubkeyToNpub:A,publicToHex:N,isHex64:H};class j{constructor(e={}){this.relayUrls=e.relays||["wss://dev-relay.lnfi.network"],this.pool=new v.SimplePool({enablePing:!0,enableReconnect:!0}),this.privateKey=e.privateKey?d.normalizeSecretKey(e.privateKey):void 0,this.publicKey=e.publicKey?d.publicToHex(e.publicKey):void 0,this.serverPublicKey=e.serverPublicKey?d.publicToHex(e.serverPublicKey):void 0,this.timeout=e.timeout||3e4}async connect(){console.log(`Client ready to use relays: ${this.relayUrls.join(", ")}`)}async call(e,r={}){return new Promise(async(s,i)=>{const y=`${Date.now()}-${Math.random()}`,l={method:e,params:r,id:y};let n,u,h=!1;const k=()=>{u&&(clearTimeout(u),u=null),n&&(n.close(),n=null)},f=(o,m)=>{h||(h=!0,k(),o?i(o):s(m))};try{const o=JSON.stringify(l),m=await g.encrypt(this.privateKey,this.serverPublicKey,o),P={kind:4,pubkey:this.publicKey,created_at:Math.floor(Date.now()/1e3),tags:[["p",this.serverPublicKey]],content:m},T=a.finalizeEvent(P,this.privateKey);u=setTimeout(()=>{f(new Error(`Request timeout after ${this.timeout}ms`))},this.timeout),n=this.pool.subscribe(this.relayUrls,{kinds:[4],"#p":[this.publicKey],authors:[this.serverPublicKey]},{onevent:async w=>{if(h)return;const c=w.tags.find(p=>p[0]==="p");if(!(!c||c[1]!==this.publicKey||w.pubkey!==this.serverPublicKey))try{const p=await g.decrypt(this.privateKey,this.serverPublicKey,w.content),b=JSON.parse(p);b.id===y&&(b.error?f(new Error(b.error)):f(null,b.result))}catch(p){console.error("Error decrypting reply:",p.message)}}}),await Promise.any(this.pool.publish(this.relayUrls,T)),console.log(`Sent ${e}`)}catch(o){f(o)}})}async sendMessage(e,r,s=!1){const i=d.publicToHex(r);return new Promise(async(y,l)=>{let n,u,h=!1;const k=()=>{u&&(clearTimeout(u),u=null),n&&(n.close(),n=null)},f=(o,m)=>{h||(h=!0,k(),o?l(o):y(m))};try{const o=await g.encrypt(this.privateKey,i,e),m={kind:4,pubkey:this.publicKey,created_at:Math.floor(Date.now()/1e3),tags:[["p",i]],content:o},P=a.finalizeEvent(m,this.privateKey),T=P.id,w=m.created_at;if(!s){await Promise.any(this.pool.publish(this.relayUrls,P)),console.log(`Message sent to ${i.slice(0,8)}`),f(null,{success:!0,timestamp:w,eventId:T});return}u=setTimeout(()=>{f(new Error(`Reply timeout after ${this.timeout}ms`))},this.timeout),n=this.pool.subscribe(this.relayUrls,{kinds:[4],"#p":[this.publicKey],authors:[i],since:w},{onevent:async c=>{if(!h){console.log(`[Client] Received reply event ${c.id.slice(0,8)} from ${c.pubkey.slice(0,8)}`),console.log("[Client] Event tags:",c.tags),console.log("[Client] Event content:",c);try{const p=c.tags.find(E=>E[0]==="p"),b=c.tags.find(E=>E[0]==="e");if(!p||p[1]!==this.publicKey||c.pubkey!==i){console.log("[Client] Skipping: p or author mismatch");return}if(b&&b[1]!==T){console.log(`[Client] Skipping: e tag mismatch (expected ${T.slice(0,8)}, got ${b[1].slice(0,8)})`);return}b||console.log("[Client] Warning: Reply has no e tag, accepting anyway");const z=await g.decrypt(this.privateKey,i,c.content);f(null,{success:!0,reply:z,sender:i,timestamp:c.created_at,eventId:c.id})}catch(p){console.error("Error decrypting reply:",p.message)}}}}),await Promise.any(this.pool.publish(this.relayUrls,P)),console.log(`Message sent to ${i.slice(0,8)}, waiting for reply...`)}catch(o){console.error("Error sending message:",o.message),f(o)}})}listenForMessages(e,r,s){const i=d.publicToHex(e);return this.pool.subscribe(this.relayUrls,{kinds:[4],"#p":[this.publicKey],authors:[i]},{onevent:async l=>{try{const n=l.tags.find(h=>h[0]==="p");if(!n||n[1]!==this.publicKey||l.pubkey!==e)return;const u=await g.decrypt(this.privateKey,i,l.content);r({text:u,sender:e,timestamp:l.created_at,eventId:l.id})}catch(n){console.error("Error decrypting message:",n.message),s&&s(n)}}})}close(){this.pool.close(this.relayUrls)}}class I extends B.EventEmitter{constructor(e={}){super(),this.relayUrls=e.relays||["wss://dev-relay.lnfi.network"],this.pool=new v.SimplePool({enablePing:!0,enableReconnect:!0}),this.privateKey=e.privateKey?d.normalizeSecretKey(e.privateKey):void 0,this.publicKey=e.publicKey?d.publicToHex(e.publicKey):void 0,this.authorWhitelist=Array.isArray(e.allowedAuthors)?e.allowedAuthors.map(d.publicToHex):[],this.methodRegistry=new Map,this.isListening=!1,this.subscription=null}registerMethod(e,r){if(typeof r!="function")throw new Error(`Handler for method "${e}" must be a function`);this.methodRegistry.set(e,r)}async start(){if(this.isListening){console.log("Already listening for messages");return}if(!this.privateKey||!this.publicKey)throw new Error("privateKey and publicKey are required");this.isListening=!0,console.log(`Starting Nostr SDK on relays: ${this.relayUrls.join(", ")}`);const e={kinds:[4],since:Math.floor(Date.now()/1e3),"#p":[this.publicKey]};this.authorWhitelist.length>0&&(e.authors=this.authorWhitelist),this.subscription=this.pool.subscribe(this.relayUrls,e,{onevent:r=>this._handleEvent(r)}),console.log("Subscribed to all relays"),this.emit("started")}async _handleEvent(e){try{console.log(`[SDK] Received event from ${e.pubkey.slice(0,8)}`);const r=e.tags.find(n=>n[0]==="p");if(!r||r[1]!==this.publicKey){console.log(`[SDK] Message not for us (expected ${this.publicKey.slice(0,8)})`);return}console.log("[SDK] Processing message for us");const s=await g.decrypt(this.privateKey,e.pubkey,e.content);let i;try{i=JSON.parse(s)}catch{await this._replyError(e.pubkey,"Invalid JSON format",null);return}if(!i.method){await this._replyError(e.pubkey,"Missing method field",null);return}const y=this.methodRegistry.get(i.method);if(!y){await this._replyError(e.pubkey,`Method not found: ${i.method}`,i.id);return}const l=await y(i.params||{},e);await this._reply(e.pubkey,{id:i.id,result:l,error:null})}catch(r){console.error("Error processing event:",r.message)}}async _reply(e,r){try{const s=JSON.stringify(r),i=await g.encrypt(this.privateKey,e,s),y={kind:4,pubkey:this.publicKey,created_at:Math.floor(Date.now()/1e3),tags:[["p",e]],content:i},l=a.finalizeEvent(y,this.privateKey);await Promise.any(this.pool.publish(this.relayUrls,l)),console.log(`Replied to ${e.slice(0,8)}`)}catch(s){console.error("Error sending reply:",s.message),this.emit("error",s)}}async _replyError(e,r,s){await this._reply(e,{id:s,result:null,error:r})}stop(){this.isListening=!1,this.subscription&&(this.subscription.close(),this.subscription=null),this.pool.close(this.relayUrls),console.log("SDK stopped"),this.emit("stopped")}}const L={NostrClient:j,NostrSdk:I,nip04:g,nip19:S,SimplePool:v.SimplePool,useWebSocketImplementation:v.useWebSocketImplementation,finalizeEvent:a.finalizeEvent,verifyEvent:a.verifyEvent,generateSecretKey:a.generateSecretKey,getPublicKey:a.getPublicKey,bytesToHex:K.bytesToHex,hexToBytes:K.hexToBytes,keyUtils:d};Object.defineProperty(exports,"finalizeEvent",{enumerable:!0,get:()=>a.finalizeEvent});Object.defineProperty(exports,"generateSecretKey",{enumerable:!0,get:()=>a.generateSecretKey});Object.defineProperty(exports,"getPublicKey",{enumerable:!0,get:()=>a.getPublicKey});Object.defineProperty(exports,"verifyEvent",{enumerable:!0,get:()=>a.verifyEvent});exports.nip04=g;Object.defineProperty(exports,"SimplePool",{enumerable:!0,get:()=>v.SimplePool});Object.defineProperty(exports,"useWebSocketImplementation",{enumerable:!0,get:()=>v.useWebSocketImplementation});exports.nip19=S;Object.defineProperty(exports,"bytesToHex",{enumerable:!0,get:()=>K.bytesToHex});Object.defineProperty(exports,"hexToBytes",{enumerable:!0,get:()=>K.hexToBytes});exports.NostrClient=j;exports.NostrSdk=I;exports.default=L;exports.keyUtils=d;
//# sourceMappingURL=index.cjs.map
