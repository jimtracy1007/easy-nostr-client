"use strict";Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});const p=require("nostr-tools/pure"),z=require("nostr-tools/nip04"),K=require("nostr-tools/pool"),A=require("nostr-tools/nip19"),w=require("@noble/hashes/utils"),j=require("events");function H(i){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(i){for(const r in i)if(r!=="default"){const t=Object.getOwnPropertyDescriptor(i,r);Object.defineProperty(e,r,t.get?t:{enumerable:!0,get:()=>i[r]})}}return e.default=i,Object.freeze(e)}const g=H(z),_=H(A);function x(i){return typeof i=="string"&&i.startsWith("nsec1")}function W(i){return typeof i=="string"&&i.startsWith("npub1")}function $(i){if(!x(i))throw new Error("Invalid nsec key");return _.decode(i).data}function T(i){if(i instanceof Uint8Array)return i;if(Buffer.isBuffer(i))return Uint8Array.from(i);if(typeof i=="string"){if(x(i))return $(i);if(M(i))return w.hexToBytes(i)}throw new Error("Unsupported secret key format")}function D(i){const e=T(i);return w.bytesToHex(e)}function R(i){const e=T(i);return _.nsecEncode(e)}function B(i){const e=T(i);return p.getPublicKey(e)}function q(i){if(!W(i))throw new Error("Invalid npub key");return _.decode(i).data.toLowerCase()}function C(i){const e=I(i);return _.npubEncode(e)}function I(i){if(i instanceof Uint8Array)return w.bytesToHex(i);if(Buffer.isBuffer(i))return Buffer.from(i).toString("hex");if(typeof i=="string"){if(W(i))return q(i);if(M(i))return i.toLowerCase()}throw new Error("Unsupported public key format")}function M(i){return typeof i=="string"&&/^[0-9a-fA-F]{64}$/.test(i)}const h={isNsecKey:x,isNpubKey:W,decodeNsecToBytes:$,normalizeSecretKey:T,secretToHex:D,encodeSecretToNsec:R,derivePubkeyFromSecret:B,decodeNpubToHex:q,encodePubkeyToNpub:C,publicToHex:I,isHex64:M};class U{constructor(e={}){this.relayUrls=e.relays||["wss://dev-relay.lnfi.network"],this.pool=new K.SimplePool({enablePing:!0,enableReconnect:!0}),this.privateKey=e.privateKey?h.normalizeSecretKey(e.privateKey):void 0,this.publicKey=e.publicKey?h.publicToHex(e.publicKey):void 0,this.serverPublicKey=e.serverPublicKey?h.publicToHex(e.serverPublicKey):void 0,this.timeout=e.timeout||3e4}async connect(){console.log(`Client ready to use relays: ${this.relayUrls.join(", ")}`)}async call(e,r={}){return new Promise(async(t,s)=>{const n=`${Date.now()}-${Math.random()}`,o={method:e,params:r,id:n};let a,c,d=!1;const E=()=>{c&&(clearTimeout(c),c=null),a&&(a.close(),a=null)},f=(l,b)=>{d||(d=!0,E(),l?s(l):t(b))};try{const l=JSON.stringify(o),b=await g.encrypt(this.privateKey,this.serverPublicKey,l),P={kind:4,pubkey:this.publicKey,created_at:Math.floor(Date.now()/1e3),tags:[["p",this.serverPublicKey]],content:b},S=p.finalizeEvent(P,this.privateKey);c=setTimeout(()=>{f(new Error(`Request timeout after ${this.timeout}ms`))},this.timeout),a=this.pool.subscribe(this.relayUrls,{kinds:[4],"#p":[this.publicKey],authors:[this.serverPublicKey]},{onevent:async v=>{if(d)return;const u=v.tags.find(y=>y[0]==="p");if(!(!u||u[1]!==this.publicKey||v.pubkey!==this.serverPublicKey))try{const y=await g.decrypt(this.privateKey,this.serverPublicKey,v.content),m=JSON.parse(y);m.id===n&&(m.error?f(new Error(m.error)):f(null,m.result))}catch(y){console.error("Error decrypting reply:",y.message)}}}),await Promise.any(this.pool.publish(this.relayUrls,S)),console.log(`Sent ${e}`)}catch(l){f(l)}})}async sendMessage(e,r,t=!1){const s=h.publicToHex(r);return new Promise(async(n,o)=>{let a,c,d=!1;const E=()=>{c&&(clearTimeout(c),c=null),a&&(a.close(),a=null)},f=(l,b)=>{d||(d=!0,E(),l?o(l):n(b))};try{const l=await g.encrypt(this.privateKey,s,e),b={kind:4,pubkey:this.publicKey,created_at:Math.floor(Date.now()/1e3),tags:[["p",s]],content:l},P=p.finalizeEvent(b,this.privateKey),S=P.id,v=b.created_at;if(!t){await Promise.any(this.pool.publish(this.relayUrls,P)),console.log(`Message sent to ${s.slice(0,8)}`),f(null,{success:!0,timestamp:v,eventId:S});return}c=setTimeout(()=>{f(new Error(`Reply timeout after ${this.timeout}ms`))},this.timeout),a=this.pool.subscribe(this.relayUrls,{kinds:[4],"#p":[this.publicKey],authors:[s],since:v},{onevent:async u=>{if(!d){console.log(`[Client] Received reply event ${u.id.slice(0,8)} from ${u.pubkey.slice(0,8)}`),console.log("[Client] Event tags:",u.tags),console.log("[Client] Event content:",u);try{const y=u.tags.find(k=>k[0]==="p"),m=u.tags.find(k=>k[0]==="e");if(!y||y[1]!==this.publicKey||u.pubkey!==s){console.log("[Client] Skipping: p or author mismatch");return}if(m&&m[1]!==S){console.log(`[Client] Skipping: e tag mismatch (expected ${S.slice(0,8)}, got ${m[1].slice(0,8)})`);return}m||console.log("[Client] Warning: Reply has no e tag, accepting anyway");const N=await g.decrypt(this.privateKey,s,u.content);f(null,{success:!0,reply:N,sender:s,timestamp:u.created_at,eventId:u.id})}catch(y){console.error("Error decrypting reply:",y.message)}}}}),await Promise.any(this.pool.publish(this.relayUrls,P)),console.log(`Message sent to ${s.slice(0,8)}, waiting for reply...`)}catch(l){console.error("Error sending message:",l.message),f(l)}})}listenForMessages(e,r,t){const s=h.publicToHex(e);return this.pool.subscribe(this.relayUrls,{kinds:[4],"#p":[this.publicKey],authors:[s]},{onevent:async o=>{try{const a=o.tags.find(d=>d[0]==="p");if(!a||a[1]!==this.publicKey||o.pubkey!==e)return;const c=await g.decrypt(this.privateKey,s,o.content);r({text:c,sender:e,timestamp:o.created_at,eventId:o.id})}catch(a){console.error("Error decrypting message:",a.message),t&&t(a)}}})}close(){this.pool.close(this.relayUrls)}}function L(){const i=[];let e=0;return{async enqueue(r){const t=`mem_${Date.now()}_${e++}`;return i.push({storageId:t,event:r}),t},async dequeueBatch(r){return i.splice(0,r)},async ack(r,t){},async size(){return i.length}}}class O extends j.EventEmitter{constructor(e={}){super(),this.relayUrls=e.relays||["wss://dev-relay.lnfi.network"],this.pool=new K.SimplePool({enablePing:!0,enableReconnect:!0}),this.privateKey=e.privateKey?h.normalizeSecretKey(e.privateKey):void 0,this.publicKey=e.publicKey?h.publicToHex(e.publicKey):void 0,this.processingMode=e.processingMode||"immediate",this.eventStorage=e.eventStorage||L(),this.processingRate=Math.min(e.processingRate||3,3),this.eventTimeout=e.eventTimeout||3e4,this._authorWhitelist=Array.isArray(e.allowedAuthors)?e.allowedAuthors.map(h.publicToHex):[],this._customGetAuthorWhitelist=e.getAuthorWhitelist,this.methodRegistry=new Map,this.isListening=!1,this.subscription=null,this.queueTimer=null,this._isProcessing=!1}registerMethod(e,r,t={}){if(typeof r!="function")throw new Error(`Handler for method "${e}" must be a function`);this.methodRegistry.set(e,{handler:r,authConfig:{authMode:t.authMode||"public",whitelist:t.whitelist||null,authHandler:t.authHandler||null}})}async getAuthorWhitelist(){if(this._customGetAuthorWhitelist){const e=this._customGetAuthorWhitelist();return e instanceof Promise?await e:e}return this._authorWhitelist.length>0?this._authorWhitelist:null}addToWhitelist(...e){const r=e.map(h.publicToHex);this._authorWhitelist.push(...r.filter(t=>!this._authorWhitelist.includes(t)))}removeFromWhitelist(...e){const r=e.map(h.publicToHex);this._authorWhitelist=this._authorWhitelist.filter(t=>!r.includes(t))}clearWhitelist(){this._authorWhitelist=[]}async isInWhitelist(e){const r=await this.getAuthorWhitelist();return!r||r.length===0?!0:r.includes(h.publicToHex(e))}async start(){if(this.isListening){console.log("Already listening for messages");return}if(!this.privateKey||!this.publicKey)throw new Error("privateKey and publicKey are required");this.isListening=!0,console.log(`Starting Nostr SDK on relays: ${this.relayUrls.join(", ")}`);const e={kinds:[4],since:Math.floor(Date.now()/1e3),"#p":[this.publicKey]};this.subscription=this.pool.subscribe(this.relayUrls,e,{onevent:r=>this._handleEvent(r)}),this.processingMode==="queued"&&this._startQueueProcessor(),console.log(`Subscribed to all relays (mode: ${this.processingMode})`),this.emit("started")}_startQueueProcessor(){const e=Math.floor(1e3/this.processingRate);this.queueTimer=setInterval(()=>this._processQueue(),e)}async _processQueue(){var e;if(!this._isProcessing){this._isProcessing=!0;try{const r=Math.max(1,this.processingRate),t=await this.eventStorage.dequeueBatch(r);if(t.length===0)return;const s=await Promise.allSettled(t.map(n=>this._processWithTimeout(n)));for(let n=0;n<t.length;n++){const o=t[n],a=s[n];if(a.status==="fulfilled")await this.eventStorage.ack(o.storageId,{status:"success"});else{const c=((e=a.reason)==null?void 0:e.message)||"Unknown error";console.error(`Error processing ${o.storageId}:`,c),await this.eventStorage.ack(o.storageId,{status:"failed",error:c})}}}catch(r){console.error("Error in queue processor:",r.message)}finally{this._isProcessing=!1}}}async _processWithTimeout(e){let r;const t=new Promise((s,n)=>{r=setTimeout(()=>n(new Error("Event processing timeout")),this.eventTimeout)});try{return await Promise.race([this._processStoredEvent(e),t])}finally{r&&clearTimeout(r)}}async _processStoredEvent(e){const{event:r}=e,t=await this.getAuthorWhitelist();if(t&&t.length>0&&!t.includes(r.pubkey))throw new Error("sender_not_allowed");await this._processDecryptedEvent(r)}async _handleEvent(e){try{const r=e.tags.find(s=>s[0]==="p");if(!r||r[1]!==this.publicKey)return;const t=await this.getAuthorWhitelist();if(t&&t.length>0&&!t.includes(e.pubkey)){console.log(`[SDK] Sender ${e.pubkey.slice(0,8)} not in whitelist`);return}this.processingMode==="immediate"?await this._processDecryptedEvent(e):await this._storeEvent(e)}catch(r){console.error("Error in _handleEvent:",r.message)}}async _storeEvent(e){var r;try{const t=await this.eventStorage.enqueue(e);console.log(`[SDK] Event ${(r=e.id)==null?void 0:r.slice(0,8)} queued as ${t}`)}catch(t){console.error("Error storing event:",t.message)}}async _processDecryptedEvent(e){try{const r=await g.decrypt(this.privateKey,e.pubkey,e.content);let t;try{t=JSON.parse(r)}catch{await this._replyError(e.pubkey,"Invalid JSON format",null);return}if(!t.method){await this._replyError(e.pubkey,"Missing method field",null);return}const s=this.methodRegistry.get(t.method);if(!s){await this._replyError(e.pubkey,`Method not found: ${t.method}`,t.id);return}if(!await this._checkPermission(t.method,e.pubkey,s.authConfig)){await this._replyError(e.pubkey,`Permission denied for method: ${t.method}`,t.id);return}const o=await s.handler(t.params||{},e,e.id,e.pubkey);await this._reply(e.pubkey,{id:t.id,result:o,error:null})}catch(r){console.error("Error processing decrypted event:",r.message)}}async _checkPermission(e,r,t){const{authMode:s,whitelist:n,authHandler:o}=t;return s==="public"?!0:s==="whitelist"?n&&n.length>0?n.includes(r):await this.isInWhitelist(r):s==="custom"&&o?await o(r):!1}async _reply(e,r){try{const t=JSON.stringify(r),s=await g.encrypt(this.privateKey,e,t),n={kind:4,pubkey:this.publicKey,created_at:Math.floor(Date.now()/1e3),tags:[["p",e]],content:s},o=p.finalizeEvent(n,this.privateKey);await Promise.any(this.pool.publish(this.relayUrls,o)),console.log(`Replied to ${e.slice(0,8)}`)}catch(t){console.error("Error sending reply:",t.message),this.emit("error",t)}}async _replyError(e,r,t){await this._reply(e,{id:t,result:null,error:r})}stop(){this.isListening=!1,this.queueTimer&&(clearInterval(this.queueTimer),this.queueTimer=null),this.subscription&&(this.subscription.close(),this.subscription=null),this.pool.close(this.relayUrls),console.log("SDK stopped"),this.emit("stopped")}}const J={NostrClient:U,NostrSdk:O,nip04:g,nip19:_,SimplePool:K.SimplePool,useWebSocketImplementation:K.useWebSocketImplementation,finalizeEvent:p.finalizeEvent,verifyEvent:p.verifyEvent,generateSecretKey:p.generateSecretKey,getPublicKey:p.getPublicKey,bytesToHex:w.bytesToHex,hexToBytes:w.hexToBytes,keyUtils:h};Object.defineProperty(exports,"finalizeEvent",{enumerable:!0,get:()=>p.finalizeEvent});Object.defineProperty(exports,"generateSecretKey",{enumerable:!0,get:()=>p.generateSecretKey});Object.defineProperty(exports,"getPublicKey",{enumerable:!0,get:()=>p.getPublicKey});Object.defineProperty(exports,"verifyEvent",{enumerable:!0,get:()=>p.verifyEvent});exports.nip04=g;Object.defineProperty(exports,"SimplePool",{enumerable:!0,get:()=>K.SimplePool});Object.defineProperty(exports,"useWebSocketImplementation",{enumerable:!0,get:()=>K.useWebSocketImplementation});exports.nip19=_;Object.defineProperty(exports,"bytesToHex",{enumerable:!0,get:()=>w.bytesToHex});Object.defineProperty(exports,"hexToBytes",{enumerable:!0,get:()=>w.hexToBytes});exports.NostrClient=U;exports.NostrSdk=O;exports.default=J;exports.keyUtils=h;
//# sourceMappingURL=index.cjs.map
