"use strict";Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});const y=require("nostr-tools/pure"),O=require("nostr-tools/nip04"),_=require("nostr-tools/pool"),N=require("nostr-tools/nip19"),w=require("@noble/hashes/utils"),j=require("events");function H(r){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(r){for(const t in r)if(t!=="default"){const i=Object.getOwnPropertyDescriptor(r,t);Object.defineProperty(e,t,i.get?i:{enumerable:!0,get:()=>r[t]})}}return e.default=r,Object.freeze(e)}const m=H(O),K=H(N);function M(r){return typeof r=="string"&&r.startsWith("nsec1")}function W(r){return typeof r=="string"&&r.startsWith("npub1")}function I(r){if(!M(r))throw new Error("Invalid nsec key");return K.decode(r).data}function k(r){if(r instanceof Uint8Array)return r;if(Buffer.isBuffer(r))return Uint8Array.from(r);if(typeof r=="string"){if(M(r))return I(r);if(B(r))return w.hexToBytes(r)}throw new Error("Unsupported secret key format")}function z(r){const e=k(r);return w.bytesToHex(e)}function D(r){const e=k(r);return K.nsecEncode(e)}function C(r){const e=k(r);return y.getPublicKey(e)}function $(r){if(!W(r))throw new Error("Invalid npub key");return K.decode(r).data.toLowerCase()}function L(r){const e=q(r);return K.npubEncode(e)}function q(r){if(r instanceof Uint8Array)return w.bytesToHex(r);if(Buffer.isBuffer(r))return Buffer.from(r).toString("hex");if(typeof r=="string"){if(W(r))return $(r);if(B(r))return r.toLowerCase()}throw new Error("Unsupported public key format")}function B(r){return typeof r=="string"&&/^[0-9a-fA-F]{64}$/.test(r)}const d={isNsecKey:M,isNpubKey:W,decodeNsecToBytes:I,normalizeSecretKey:k,secretToHex:z,encodeSecretToNsec:D,derivePubkeyFromSecret:C,decodeNpubToHex:$,encodePubkeyToNpub:L,publicToHex:q,isHex64:B};class U{constructor(e={}){this.relayUrls=e.relays||["wss://dev-relay.lnfi.network"],this.pool=new _.SimplePool({enablePing:!0,enableReconnect:!0}),this.privateKey=e.privateKey?d.normalizeSecretKey(e.privateKey):void 0,this.publicKey=e.publicKey?d.publicToHex(e.publicKey):void 0,this.serverPublicKey=e.serverPublicKey?d.publicToHex(e.serverPublicKey):void 0,this.additionalTags=Array.isArray(e.tags)?e.tags:[],this.replyFilterBuilder=this._validateFilterBuilder(e.replyFilter),this.messageReplyFilterBuilder=this._validateFilterBuilder(e.messageReplyFilter||e.replyFilter),this.incomingFilterBuilder=this._validateFilterBuilder(e.incomingFilter),this.timeout=e.timeout||3e4}setTags(e=[]){if(!Array.isArray(e))throw new Error("tags must be an array");this.additionalTags=e}setReplyFilter(e){this.replyFilterBuilder=this._validateFilterBuilder(e)}setMessageReplyFilter(e){this.messageReplyFilterBuilder=this._validateFilterBuilder(e)}setIncomingFilter(e){this.incomingFilterBuilder=this._validateFilterBuilder(e)}_validateFilterBuilder(e){if(e==null)return null;if(typeof e!="function")throw new Error("Filter override must be a function accepting (baseFilter, context)");return e}_buildFilter(e,t,i){const s={...e};if(!t)return s;const n=t({...s},i)||s;if(typeof n!="object"||n===null)throw new Error("Filter builder must return an object");return n}async connect(){console.log(`Client ready to use relays: ${this.relayUrls.join(", ")}`)}async call(e,t={}){return new Promise(async(i,s)=>{const n=`${Date.now()}-${Math.random()}`,l={method:e,params:t,id:n};let a,o,u=!1;const T=()=>{o&&(clearTimeout(o),o=null),a&&(a.close(),a=null)},p=(c,b)=>{u||(u=!0,T(),c?s(c):i(b))};try{const c=JSON.stringify(l),b=await m.encrypt(this.privateKey,this.serverPublicKey,c),P={kind:4,pubkey:this.publicKey,created_at:Math.floor(Date.now()/1e3),tags:[["p",this.serverPublicKey],...this.additionalTags],content:b},v=y.finalizeEvent(P,this.privateKey);o=setTimeout(()=>{p(new Error(`Request timeout after ${this.timeout}ms`))},this.timeout);const S={kinds:[4],"#p":[this.publicKey],authors:[this.serverPublicKey]},F=this._buildFilter(S,this.replyFilterBuilder,{method:e,params:t,requestId:n});a=this.pool.subscribe(this.relayUrls,F,{onevent:async E=>{if(u)return;const h=E.tags.find(f=>f[0]==="p");if(!(!h||h[1]!==this.publicKey||E.pubkey!==this.serverPublicKey))try{const f=await m.decrypt(this.privateKey,this.serverPublicKey,E.content),g=JSON.parse(f);g.id===n&&(g.error?p(new Error(g.error)):p(null,g.result))}catch(f){console.error("Error decrypting reply:",f.message)}}}),await Promise.any(this.pool.publish(this.relayUrls,v)),console.log(`Sent ${e}`)}catch(c){p(c)}})}async sendMessage(e,t,i=!1){const s=d.publicToHex(t);return new Promise(async(n,l)=>{let a,o,u=!1;const T=()=>{o&&(clearTimeout(o),o=null),a&&(a.close(),a=null)},p=(c,b)=>{u||(u=!0,T(),c?l(c):n(b))};try{const c=await m.encrypt(this.privateKey,s,e),b={kind:4,pubkey:this.publicKey,created_at:Math.floor(Date.now()/1e3),tags:[["p",s],...this.additionalTags],content:c},P=y.finalizeEvent(b,this.privateKey),v=P.id,S=b.created_at;if(!i){await Promise.any(this.pool.publish(this.relayUrls,P)),console.log(`Message sent to ${s.slice(0,8)}`),p(null,{success:!0,timestamp:S,eventId:v});return}o=setTimeout(()=>{p(new Error(`Reply timeout after ${this.timeout}ms`))},this.timeout);const F={kinds:[4],"#p":[this.publicKey],authors:[s],since:S},E=this._buildFilter(F,this.messageReplyFilterBuilder,{recipientPubkey:s,sentEventId:v,sentTimestamp:S});a=this.pool.subscribe(this.relayUrls,E,{onevent:async h=>{if(!u){console.log(`[Client] Received reply event ${h.id.slice(0,8)} from ${h.pubkey.slice(0,8)}`),console.log("[Client] Event tags:",h.tags),console.log("[Client] Event content:",h);try{const f=h.tags.find(x=>x[0]==="p"),g=h.tags.find(x=>x[0]==="e");if(!f||f[1]!==this.publicKey||h.pubkey!==s){console.log("[Client] Skipping: p or author mismatch");return}if(g&&g[1]!==v){console.log(`[Client] Skipping: e tag mismatch (expected ${v.slice(0,8)}, got ${g[1].slice(0,8)})`);return}g||console.log("[Client] Warning: Reply has no e tag, accepting anyway");const R=await m.decrypt(this.privateKey,s,h.content);p(null,{success:!0,reply:R,sender:s,timestamp:h.created_at,eventId:h.id})}catch(f){console.error("Error decrypting reply:",f.message)}}}}),await Promise.any(this.pool.publish(this.relayUrls,P)),console.log(`Message sent to ${s.slice(0,8)}, waiting for reply...`)}catch(c){console.error("Error sending message:",c.message),p(c)}})}listenForMessages(e,t,i){const s=d.publicToHex(e),n={kinds:[4],"#p":[this.publicKey],authors:[s]},l=this._buildFilter(n,this.incomingFilterBuilder,{senderPubkey:s});return this.pool.subscribe(this.relayUrls,l,{onevent:async o=>{try{const u=o.tags.find(p=>p[0]==="p");if(!u||u[1]!==this.publicKey||o.pubkey!==e)return;const T=await m.decrypt(this.privateKey,s,o.content);t({text:T,sender:e,timestamp:o.created_at,eventId:o.id})}catch(u){console.error("Error decrypting message:",u.message),i&&i(u)}}})}close(){this.pool.close(this.relayUrls)}}function J(){const r=[];let e=0;return{async enqueue(t){const i=`mem_${Date.now()}_${e++}`;return r.push({storageId:i,event:t}),i},async dequeueBatch(t){return r.splice(0,t)},async ack(t,i){},async size(){return r.length}}}class A extends j.EventEmitter{constructor(e={}){super(),this.relayUrls=e.relays||["wss://dev-relay.lnfi.network"],this.pool=new _.SimplePool({enablePing:!0,enableReconnect:!0}),this.privateKey=e.privateKey?d.normalizeSecretKey(e.privateKey):void 0,this.publicKey=e.publicKey?d.publicToHex(e.publicKey):void 0,this.processingMode=e.processingMode||"immediate",this.eventStorage=e.eventStorage||J(),this.processingRate=Math.min(e.processingRate||3,3),this.eventTimeout=e.eventTimeout||3e4,this._authorWhitelist=Array.isArray(e.allowedAuthors)?e.allowedAuthors.map(d.publicToHex):[],this._customGetAuthorWhitelist=e.getAuthorWhitelist,this.methodRegistry=new Map,this.isListening=!1,this.subscription=null,this.queueTimer=null,this._isProcessing=!1}registerMethod(e,t,i={}){if(typeof t!="function")throw new Error(`Handler for method "${e}" must be a function`);this.methodRegistry.set(e,{handler:t,authConfig:{authMode:i.authMode||"public",whitelist:i.whitelist||null,authHandler:i.authHandler||null}})}async getAuthorWhitelist(){if(this._customGetAuthorWhitelist){const e=this._customGetAuthorWhitelist();return e instanceof Promise?await e:e}return this._authorWhitelist.length>0?this._authorWhitelist:null}addToWhitelist(...e){const t=e.map(d.publicToHex);this._authorWhitelist.push(...t.filter(i=>!this._authorWhitelist.includes(i)))}removeFromWhitelist(...e){const t=e.map(d.publicToHex);this._authorWhitelist=this._authorWhitelist.filter(i=>!t.includes(i))}clearWhitelist(){this._authorWhitelist=[]}async isInWhitelist(e){const t=await this.getAuthorWhitelist();return!t||t.length===0?!0:t.includes(d.publicToHex(e))}async start(){if(this.isListening){console.log("Already listening for messages");return}if(!this.privateKey||!this.publicKey)throw new Error("privateKey and publicKey are required");this.isListening=!0,console.log(`Starting Nostr SDK on relays: ${this.relayUrls.join(", ")}`);const e={kinds:[4],since:Math.floor(Date.now()/1e3),"#p":[this.publicKey]};this.subscription=this.pool.subscribe(this.relayUrls,e,{onevent:t=>this._handleEvent(t)}),this.processingMode==="queued"&&this._startQueueProcessor(),console.log(`Subscribed to all relays (mode: ${this.processingMode})`),this.emit("started")}_startQueueProcessor(){const e=Math.floor(1e3/this.processingRate);this.queueTimer=setInterval(()=>this._processQueue(),e)}async _processQueue(){var e;if(!this._isProcessing){this._isProcessing=!0;try{const t=Math.max(1,this.processingRate),i=await this.eventStorage.dequeueBatch(t);if(i.length===0)return;const s=await Promise.allSettled(i.map(n=>this._processWithTimeout(n)));for(let n=0;n<i.length;n++){const l=i[n],a=s[n];if(a.status==="fulfilled")await this.eventStorage.ack(l.storageId,{status:"success"});else{const o=((e=a.reason)==null?void 0:e.message)||"Unknown error";console.error(`Error processing ${l.storageId}:`,o),await this.eventStorage.ack(l.storageId,{status:"failed",error:o})}}}catch(t){console.error("Error in queue processor:",t.message)}finally{this._isProcessing=!1}}}async _processWithTimeout(e){let t;const i=new Promise((s,n)=>{t=setTimeout(()=>n(new Error("Event processing timeout")),this.eventTimeout)});try{return await Promise.race([this._processStoredEvent(e),i])}finally{t&&clearTimeout(t)}}async _processStoredEvent(e){const{event:t}=e,i=await this.getAuthorWhitelist();if(i&&i.length>0&&!i.includes(t.pubkey))throw new Error("sender_not_allowed");await this._processDecryptedEvent(t)}async _handleEvent(e){try{const t=e.tags.find(s=>s[0]==="p");if(!t||t[1]!==this.publicKey)return;const i=await this.getAuthorWhitelist();if(i&&i.length>0&&!i.includes(e.pubkey)){console.log(`[SDK] Sender ${e.pubkey.slice(0,8)} not in whitelist`);return}this.processingMode==="immediate"?await this._processDecryptedEvent(e):await this._storeEvent(e)}catch(t){console.error("Error in _handleEvent:",t.message)}}async _storeEvent(e){var t;try{const i=await this.eventStorage.enqueue(e);console.log(`[SDK] Event ${(t=e.id)==null?void 0:t.slice(0,8)} queued as ${i}`)}catch(i){console.error("Error storing event:",i.message)}}async _processDecryptedEvent(e){try{const t=await m.decrypt(this.privateKey,e.pubkey,e.content);let i;try{i=JSON.parse(t)}catch{await this._replyError(e.pubkey,"Invalid JSON format",null);return}if(!i.method){await this._replyError(e.pubkey,"Missing method field",null);return}const s=this.methodRegistry.get(i.method);if(!s){await this._replyError(e.pubkey,`Method not found: ${i.method}`,i.id);return}if(!await this._checkPermission(i.method,e.pubkey,s.authConfig)){await this._replyError(e.pubkey,`Permission denied for method: ${i.method}`,i.id);return}const l=await s.handler(i.params||{},e,e.id,e.pubkey);await this._reply(e.pubkey,{id:i.id,result:l,error:null})}catch(t){console.error("Error processing decrypted event:",t.message)}}async _checkPermission(e,t,i){const{authMode:s,whitelist:n,authHandler:l}=i;return s==="public"?!0:s==="whitelist"?n&&n.length>0?n.includes(t):await this.isInWhitelist(t):s==="custom"&&l?await l(t):!1}async _reply(e,t){try{const i=JSON.stringify(t),s=await m.encrypt(this.privateKey,e,i),n={kind:4,pubkey:this.publicKey,created_at:Math.floor(Date.now()/1e3),tags:[["p",e]],content:s},l=y.finalizeEvent(n,this.privateKey);await Promise.any(this.pool.publish(this.relayUrls,l)),console.log(`Replied to ${e.slice(0,8)}`)}catch(i){console.error("Error sending reply:",i.message),this.emit("error",i)}}async _replyError(e,t,i){await this._reply(e,{id:i,result:null,error:t})}stop(){this.isListening=!1,this.queueTimer&&(clearInterval(this.queueTimer),this.queueTimer=null),this.subscription&&(this.subscription.close(),this.subscription=null),this.pool.close(this.relayUrls),console.log("SDK stopped"),this.emit("stopped")}}const Q={NostrClient:U,NostrSdk:A,nip04:m,nip19:K,SimplePool:_.SimplePool,useWebSocketImplementation:_.useWebSocketImplementation,finalizeEvent:y.finalizeEvent,verifyEvent:y.verifyEvent,generateSecretKey:y.generateSecretKey,getPublicKey:y.getPublicKey,bytesToHex:w.bytesToHex,hexToBytes:w.hexToBytes,keyUtils:d};Object.defineProperty(exports,"finalizeEvent",{enumerable:!0,get:()=>y.finalizeEvent});Object.defineProperty(exports,"generateSecretKey",{enumerable:!0,get:()=>y.generateSecretKey});Object.defineProperty(exports,"getPublicKey",{enumerable:!0,get:()=>y.getPublicKey});Object.defineProperty(exports,"verifyEvent",{enumerable:!0,get:()=>y.verifyEvent});exports.nip04=m;Object.defineProperty(exports,"SimplePool",{enumerable:!0,get:()=>_.SimplePool});Object.defineProperty(exports,"useWebSocketImplementation",{enumerable:!0,get:()=>_.useWebSocketImplementation});exports.nip19=K;Object.defineProperty(exports,"bytesToHex",{enumerable:!0,get:()=>w.bytesToHex});Object.defineProperty(exports,"hexToBytes",{enumerable:!0,get:()=>w.hexToBytes});exports.NostrClient=U;exports.NostrSdk=A;exports.default=Q;exports.keyUtils=d;
//# sourceMappingURL=index.cjs.map
