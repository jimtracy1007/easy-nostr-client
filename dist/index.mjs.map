{"version":3,"file":"index.mjs","sources":["../src/keyUtils.js","../src/nostrClient.js","../src/nostrSdk.js","../index.js"],"sourcesContent":["import { getPublicKey } from 'nostr-tools/pure';\nimport * as nip19 from 'nostr-tools/nip19';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\n\n/**\n * Determine if a value is an nsec (NIP-19 secret key)\n */\nexport function isNsecKey(value) {\n  return typeof value === 'string' && value.startsWith('nsec1');\n}\n\n/**\n * Determine if a value is an npub (NIP-19 public key)\n */\nexport function isNpubKey(value) {\n  return typeof value === 'string' && value.startsWith('npub1');\n}\n\n/**\n * Convert nsec to Uint8Array\n */\nexport function decodeNsecToBytes(nsecKey) {\n  if (!isNsecKey(nsecKey)) {\n    throw new Error('Invalid nsec key');\n  }\n  const decoded = nip19.decode(nsecKey);\n  return decoded.data;\n}\n\n/**\n * Convert secret key (nsec | hex | Uint8Array) to Uint8Array\n */\nexport function normalizeSecretKey(secret) {\n  if (secret instanceof Uint8Array) {\n    return secret;\n  }\n  if (Buffer.isBuffer(secret)) {\n    return Uint8Array.from(secret);\n  }\n  if (typeof secret === 'string') {\n    if (isNsecKey(secret)) {\n      return decodeNsecToBytes(secret);\n    }\n    if (isHex64(secret)) {\n      return hexToBytes(secret);\n    }\n  }\n  throw new Error('Unsupported secret key format');\n}\n\n/**\n * Convert Uint8Array/Buffer/hex secret key to hex string\n */\nexport function secretToHex(secret) {\n  const bytes = normalizeSecretKey(secret);\n  return bytesToHex(bytes);\n}\n\n/**\n * Convert secret key to nsec string\n */\nexport function encodeSecretToNsec(secret) {\n  const bytes = normalizeSecretKey(secret);\n  return nip19.nsecEncode(bytes);\n}\n\n/**\n * Derive hex public key from secret (nsec | hex | Uint8Array)\n */\nexport function derivePubkeyFromSecret(secret) {\n  const bytes = normalizeSecretKey(secret);\n  return getPublicKey(bytes);\n}\n\n/**\n * Convert npub to hex public key\n */\nexport function decodeNpubToHex(npubKey) {\n  if (!isNpubKey(npubKey)) {\n    throw new Error('Invalid npub key');\n  }\n  const decoded = nip19.decode(npubKey);\n  return decoded.data.toLowerCase();\n}\n\n/**\n * Convert hex/Uint8Array public key to npub\n */\nexport function encodePubkeyToNpub(pubkey) {\n  const hex = publicToHex(pubkey);\n  return nip19.npubEncode(hex);\n}\n\n/**\n * Normalize public key to hex string\n */\nexport function publicToHex(pubkey) {\n  if (pubkey instanceof Uint8Array) {\n    return bytesToHex(pubkey);\n  }\n  if (Buffer.isBuffer(pubkey)) {\n    return Buffer.from(pubkey).toString('hex');\n  }\n  if (typeof pubkey === 'string') {\n    if (isNpubKey(pubkey)) {\n      return decodeNpubToHex(pubkey);\n    }\n    if (isHex64(pubkey)) {\n      return pubkey.toLowerCase();\n    }\n  }\n  throw new Error('Unsupported public key format');\n}\n\nexport function isHex64(value) {\n  return typeof value === 'string' && /^[0-9a-fA-F]{64}$/.test(value);\n}\n\nconst keyUtils = {\n  isNsecKey,\n  isNpubKey,\n  decodeNsecToBytes,\n  normalizeSecretKey,\n  secretToHex,\n  encodeSecretToNsec,\n  derivePubkeyFromSecret,\n  decodeNpubToHex,\n  encodePubkeyToNpub,\n  publicToHex,\n  isHex64,\n};\n\nexport default keyUtils;\n","import { finalizeEvent } from 'nostr-tools/pure';\nimport * as nip04 from 'nostr-tools/nip04';\nimport { SimplePool } from 'nostr-tools/pool';\nimport keyUtils from './keyUtils.js';\n\n/**\n * Nostr Client - sends requests to the SDK backend\n */\nclass NostrClient {\n  constructor(options = {}) {\n    this.relayUrls = options.relays || ['wss://dev-relay.lnfi.network'];\n    this.pool = new SimplePool({ enablePing: true, enableReconnect: true });\n    this.privateKey = options.privateKey\n      ? keyUtils.normalizeSecretKey(options.privateKey)\n      : undefined;\n   this.publicKey = options.publicKey\n         ? keyUtils.publicToHex(options.publicKey)\n         : undefined;\n    this.serverPublicKey = options.serverPublicKey\n         ? keyUtils.publicToHex(options.serverPublicKey)\n         : undefined;\n    this.timeout = options.timeout || 30000;\n  }\n\n  /**\n   * Initialize connection (SimplePool manages connections automatically)\n   */\n  async connect() {\n    // SimplePool connects automatically when subscribing; keep method for compatibility\n    console.log(`Client ready to use relays: ${this.relayUrls.join(', ')}`);\n  }\n\n  /**\n   * Send RPC request\n   */\n  async call(method, params = {}) {\n    return new Promise(async (resolve, reject) => {\n      const requestId = `${Date.now()}-${Math.random()}`;\n      const request = { method, params, id: requestId };\n\n      let subscription;\n      let timeoutId;\n      let settled = false;\n\n      const cleanup = () => {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n          timeoutId = null;\n        }\n        if (subscription) {\n          subscription.close();\n          subscription = null;\n        }\n      };\n\n      const finalize = (error, result) => {\n        if (settled) return;\n        settled = true;\n        cleanup();\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      };\n\n      try {\n        const plaintext = JSON.stringify(request);\n        const encrypted = await nip04.encrypt(\n          this.privateKey,\n          this.serverPublicKey,\n          plaintext\n        );\n\n        const event = {\n          kind: 4,\n          pubkey: this.publicKey,\n          created_at: Math.floor(Date.now() / 1000),\n          tags: [['p', this.serverPublicKey]],\n          content: encrypted,\n        };\n\n        const signed = finalizeEvent(event, this.privateKey);\n\n        timeoutId = setTimeout(() => {\n          finalize(new Error(`Request timeout after ${this.timeout}ms`));\n        }, this.timeout);\n\n        subscription = this.pool.subscribe(\n          this.relayUrls,\n          { kinds: [4], '#p': [this.publicKey], authors: [this.serverPublicKey] },\n          {\n            onevent: async (replyEvent) => {\n              if (settled) return;\n\n              const pTag = replyEvent.tags.find(t => t[0] === 'p');\n              if (!pTag || pTag[1] !== this.publicKey || replyEvent.pubkey !== this.serverPublicKey) {\n                return;\n              }\n\n              try {\n                const decrypted = await nip04.decrypt(\n                  this.privateKey,\n                  this.serverPublicKey,\n                  replyEvent.content\n                );\n                const response = JSON.parse(decrypted);\n\n                if (response.id === requestId) {\n                  if (response.error) {\n                    finalize(new Error(response.error));\n                  } else {\n                    finalize(null, response.result);\n                  }\n                }\n              } catch (err) {\n                console.error('Error decrypting reply:', err.message);\n              }\n            },\n          }\n        );\n\n        await Promise.any(this.pool.publish(this.relayUrls, signed));\n\n        console.log(`Sent ${method}`);\n      } catch (error) {\n        finalize(error);\n      }\n    });\n  }\n\n  /**\n   * Send plain text direct message and wait for reply\n   */\n  async sendMessage(text, recipientPubkey, waitForReply = false) {\n    const recipientPubkeyHex = keyUtils.publicToHex(recipientPubkey);\n\n    return new Promise(async (resolve, reject) => {\n      let subscription;\n      let timeoutId;\n      let settled = false;\n\n      const cleanup = () => {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n          timeoutId = null;\n        }\n        if (subscription) {\n          subscription.close();\n          subscription = null;\n        }\n      };\n\n      const finalize = (error, result) => {\n        if (settled) return;\n        settled = true;\n        cleanup();\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      };\n\n      try {\n        const encrypted = await nip04.encrypt(\n          this.privateKey,\n          recipientPubkeyHex,\n          text\n        );\n\n        const event = {\n          kind: 4,\n          pubkey: this.publicKey,\n          created_at: Math.floor(Date.now() / 1000),\n          tags: [['p', recipientPubkeyHex]],\n          content: encrypted,\n        };\n\n        const signed = finalizeEvent(event, this.privateKey);\n        const sentEventId = signed.id;\n        const sentTimestamp = event.created_at;\n\n        if (!waitForReply) {\n          await Promise.any(this.pool.publish(this.relayUrls, signed));\n          console.log(`Message sent to ${recipientPubkeyHex.slice(0, 8)}`);\n          finalize(null, { success: true, timestamp: sentTimestamp, eventId: sentEventId });\n          return;\n        }\n\n        timeoutId = setTimeout(() => {\n          finalize(new Error(`Reply timeout after ${this.timeout}ms`));\n        }, this.timeout);\n\n        subscription = this.pool.subscribe(\n          this.relayUrls,\n          { kinds: [4], '#p': [this.publicKey], authors: [recipientPubkeyHex], since: sentTimestamp },\n          {\n            onevent: async (replyEvent) => {\n              if (settled) return;\n\n              console.log(`[Client] Received reply event ${replyEvent.id.slice(0, 8)} from ${replyEvent.pubkey.slice(0, 8)}`);\n              console.log(`[Client] Event tags:`, replyEvent.tags);\n              console.log(`[Client] Event content:`, replyEvent);\n\n              try {\n                const pTag = replyEvent.tags.find(t => t[0] === 'p');\n                const eTag = replyEvent.tags.find(t => t[0] === 'e');\n                if (!pTag || pTag[1] !== this.publicKey || replyEvent.pubkey !== recipientPubkeyHex) {\n                  console.log(`[Client] Skipping: p or author mismatch`);\n                  return;\n                }\n                if (eTag && eTag[1] !== sentEventId) {\n                  console.log(`[Client] Skipping: e tag mismatch (expected ${sentEventId.slice(0, 8)}, got ${eTag[1].slice(0, 8)})`);\n                  return;\n                }\n                if (!eTag) {\n                  console.log(`[Client] Warning: Reply has no e tag, accepting anyway`);\n                }\n\n                const decrypted = await nip04.decrypt(\n                  this.privateKey,\n                  recipientPubkeyHex,\n                  replyEvent.content\n                );\n\n                finalize(null, {\n                  success: true,\n                  reply: decrypted,\n                  sender: recipientPubkeyHex,\n                  timestamp: replyEvent.created_at,\n                  eventId: replyEvent.id,\n                });\n              } catch (err) {\n                console.error('Error decrypting reply:', err.message);\n              }\n            },\n          }\n        );\n\n        await Promise.any(this.pool.publish(this.relayUrls, signed));\n        console.log(`Message sent to ${recipientPubkeyHex.slice(0, 8)}, waiting for reply...`);\n      } catch (error) {\n        console.error('Error sending message:', error.message);\n        finalize(error);\n      }\n    });\n  }\n\n  /**\n   * Listen for plain text direct messages from a specific sender\n   */\n  listenForMessages(senderPubkey, onMessage, onError) {\n    const senderPubkeyHex = keyUtils.publicToHex(senderPubkey);\n    const subscription = this.pool.subscribe(\n      this.relayUrls,\n      { kinds: [4], '#p': [this.publicKey], authors: [senderPubkeyHex] },\n      {\n        onevent: async (event) => {\n          try {\n            const pTag = event.tags.find(t => t[0] === 'p');\n            if (!pTag || pTag[1] !== this.publicKey || event.pubkey !== senderPubkey) {\n              return;\n            }\n\n            const decrypted = await nip04.decrypt(\n              this.privateKey,\n              senderPubkeyHex,\n              event.content\n            );\n\n            onMessage({\n              text: decrypted,\n              sender: senderPubkey,\n              timestamp: event.created_at,\n              eventId: event.id,\n            });\n          } catch (err) {\n            console.error('Error decrypting message:', err.message);\n            if (onError) onError(err);\n          }\n        },\n      }\n    );\n\n    return subscription;\n  }\n\n  /**\n   * Close connections\n   */\n  close() {\n    this.pool.close(this.relayUrls);\n  }\n}\n\nexport default NostrClient;\n","import { finalizeEvent } from 'nostr-tools/pure';\nimport * as nip04 from 'nostr-tools/nip04';\nimport { SimplePool } from 'nostr-tools/pool';\nimport { EventEmitter } from 'events';\nimport keyUtils from './keyUtils.js';\n\n/**\n * Nostr SDK - Backend server\n * Listen for direct messages, parse JSON-RPC style requests, call business methods, and return results\n */\nclass NostrSdk extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.relayUrls = options.relays || ['wss://dev-relay.lnfi.network'];\n    this.pool = new SimplePool({ enablePing: true, enableReconnect: true });\n    this.privateKey = options.privateKey\n      ? keyUtils.normalizeSecretKey(options.privateKey)\n      : undefined;\n    this.publicKey = options.publicKey\n      ? keyUtils.publicToHex(options.publicKey)\n      : undefined;\n    this.authorWhitelist = Array.isArray(options.allowedAuthors)\n      ? options.allowedAuthors.map(keyUtils.publicToHex)\n      : [];\n    this.methodRegistry = new Map();\n    this.isListening = false;\n    this.subscription = null;\n  }\n\n  /**\n   * Register business methods\n   */\n  registerMethod(method, handler) {\n    if (typeof handler !== 'function') {\n      throw new Error(`Handler for method \"${method}\" must be a function`);\n    }\n    this.methodRegistry.set(method, handler);\n  }\n\n  /**\n   * Start listening\n   */\n  async start() {\n    if (this.isListening) {\n      console.log('Already listening for messages');\n      return;\n    }\n\n    if (!this.privateKey || !this.publicKey) {\n      throw new Error('privateKey and publicKey are required');\n    }\n\n    this.isListening = true;\n    console.log(`Starting Nostr SDK on relays: ${this.relayUrls.join(', ')}`);\n\n    // Use SimplePool to subscribe to direct message events (kind 4)\n    // Use since to only get new messages, not load history\n    const filter = {\n      kinds: [4],\n      since: Math.floor(Date.now() / 1000),\n      '#p': [this.publicKey],\n    };\n\n    if (this.authorWhitelist.length > 0) {\n      filter.authors = this.authorWhitelist;\n    }\n\n    this.subscription = this.pool.subscribe(\n      this.relayUrls,\n      filter,\n      {\n        onevent: (event) => this._handleEvent(event),\n      }\n    );\n\n    console.log(`Subscribed to all relays`);\n    this.emit('started');\n  }\n\n  /**\n   * Handle received events\n   */\n  async _handleEvent(event) {\n    try {\n      console.log(`[SDK] Received event from ${event.pubkey.slice(0, 8)}`);\n      \n      // Check if this message is for us\n      const pTag = event.tags.find(t => t[0] === 'p');\n      if (!pTag || pTag[1] !== this.publicKey) {\n        console.log(`[SDK] Message not for us (expected ${this.publicKey.slice(0, 8)})`);\n        return; // Not a message for us\n      }\n      \n      console.log(`[SDK] Processing message for us`);\n\n      // Decrypt direct message content\n      const decrypted = await nip04.decrypt(this.privateKey, event.pubkey, event.content);\n\n      // Try to parse JSON\n      let request;\n      try {\n        request = JSON.parse(decrypted);\n      } catch (e) {\n        await this._replyError(event.pubkey, 'Invalid JSON format', null);\n        return;\n      }\n\n      // Validate request format\n      if (!request.method) {\n        await this._replyError(event.pubkey, 'Missing method field', null);\n        return;\n      }\n\n      // Call business method\n      const handler = this.methodRegistry.get(request.method);\n      if (!handler) {\n        await this._replyError(event.pubkey, `Method not found: ${request.method}`, request.id);\n        return;\n      }\n\n      const result = await handler(request.params || {}, event);\n\n      // Return result\n      await this._reply(event.pubkey, {\n        id: request.id,\n        result,\n        error: null,\n      });\n    } catch (error) {\n      console.error('Error processing event:', error.message);\n    }\n  }\n\n  /**\n   * Send direct message reply\n   */\n  async _reply(recipientPubkey, data) {\n    try {\n      const plaintext = JSON.stringify(data);\n      const encrypted = await nip04.encrypt(this.privateKey, recipientPubkey, plaintext);\n\n      const event = {\n        kind: 4,\n        pubkey: this.publicKey,\n        created_at: Math.floor(Date.now() / 1000),\n        tags: [['p', recipientPubkey]],\n        content: encrypted,\n      };\n\n      const signed = finalizeEvent(event, this.privateKey);\n\n      // Use SimplePool to publish to all relays\n      await Promise.any(this.pool.publish(this.relayUrls, signed));\n\n      console.log(`Replied to ${recipientPubkey.slice(0, 8)}`);\n    } catch (error) {\n      console.error('Error sending reply:', error.message);\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Send error reply\n   */\n  async _replyError(recipientPubkey, message, requestId) {\n    await this._reply(recipientPubkey, {\n      id: requestId,\n      result: null,\n      error: message,\n    });\n  }\n\n  /**\n   * Stop listening\n   */\n  stop() {\n    this.isListening = false;\n\n    // Close subscription\n    if (this.subscription) {\n      this.subscription.close();\n      this.subscription = null;\n    }\n\n    // Close SimplePool\n    this.pool.close(this.relayUrls);\n\n    console.log('SDK stopped');\n    this.emit('stopped');\n  }\n}\n\nexport default NostrSdk;","import NostrClient from './src/nostrClient.js';\nimport NostrSdk from './src/nostrSdk.js';\nimport keyUtils from './src/keyUtils.js';\n\nimport * as nip04 from 'nostr-tools/nip04';\nimport * as nip19 from 'nostr-tools/nip19';\nimport { SimplePool, useWebSocketImplementation } from 'nostr-tools/pool';\nimport {\n  finalizeEvent,\n  verifyEvent,\n  generateSecretKey,\n  getPublicKey,\n} from 'nostr-tools/pure';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\n\nconst api = {\n  NostrClient,\n  NostrSdk,\n  nip04,\n  nip19,\n  SimplePool,\n  useWebSocketImplementation,\n  finalizeEvent,\n  verifyEvent,\n  generateSecretKey,\n  getPublicKey,\n  bytesToHex,\n  hexToBytes,\n  keyUtils,\n};\n\nexport {\n  NostrClient,\n  NostrSdk,\n  nip04,\n  nip19,\n  SimplePool,\n  useWebSocketImplementation,\n  finalizeEvent,\n  verifyEvent,\n  generateSecretKey,\n  getPublicKey,\n  bytesToHex,\n  hexToBytes,\n  keyUtils,\n};\n\nexport default api;\n"],"names":["isNsecKey","value","isNpubKey","decodeNsecToBytes","nsecKey","nip19","normalizeSecretKey","secret","isHex64","hexToBytes","secretToHex","bytes","bytesToHex","encodeSecretToNsec","derivePubkeyFromSecret","getPublicKey","decodeNpubToHex","npubKey","encodePubkeyToNpub","pubkey","hex","publicToHex","keyUtils","NostrClient","options","SimplePool","method","params","resolve","reject","requestId","request","subscription","timeoutId","settled","cleanup","finalize","error","result","plaintext","encrypted","nip04","event","signed","finalizeEvent","replyEvent","pTag","t","decrypted","response","err","text","recipientPubkey","waitForReply","recipientPubkeyHex","sentEventId","sentTimestamp","eTag","senderPubkey","onMessage","onError","senderPubkeyHex","NostrSdk","EventEmitter","handler","filter","data","message","api","useWebSocketImplementation","verifyEvent","generateSecretKey"],"mappings":"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"}