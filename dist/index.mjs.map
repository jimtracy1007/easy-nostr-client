{"version":3,"file":"index.mjs","sources":["../src/keyUtils.js","../src/nostrClient.js","../src/nostrSdk.js","../index.js"],"sourcesContent":["import { getPublicKey } from 'nostr-tools/pure';\nimport * as nip19 from 'nostr-tools/nip19';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\n\n/**\n * Determine if a value is an nsec (NIP-19 secret key)\n */\nexport function isNsecKey(value) {\n  return typeof value === 'string' && value.startsWith('nsec1');\n}\n\n/**\n * Determine if a value is an npub (NIP-19 public key)\n */\nexport function isNpubKey(value) {\n  return typeof value === 'string' && value.startsWith('npub1');\n}\n\n/**\n * Convert nsec to Uint8Array\n */\nexport function decodeNsecToBytes(nsecKey) {\n  if (!isNsecKey(nsecKey)) {\n    throw new Error('Invalid nsec key');\n  }\n  const decoded = nip19.decode(nsecKey);\n  return decoded.data;\n}\n\n/**\n * Convert secret key (nsec | hex | Uint8Array) to Uint8Array\n */\nexport function normalizeSecretKey(secret) {\n  if (secret instanceof Uint8Array) {\n    return secret;\n  }\n  if (Buffer.isBuffer(secret)) {\n    return Uint8Array.from(secret);\n  }\n  if (typeof secret === 'string') {\n    if (isNsecKey(secret)) {\n      return decodeNsecToBytes(secret);\n    }\n    if (isHex64(secret)) {\n      return hexToBytes(secret);\n    }\n  }\n  throw new Error('Unsupported secret key format');\n}\n\n/**\n * Convert Uint8Array/Buffer/hex secret key to hex string\n */\nexport function secretToHex(secret) {\n  const bytes = normalizeSecretKey(secret);\n  return bytesToHex(bytes);\n}\n\n/**\n * Convert secret key to nsec string\n */\nexport function encodeSecretToNsec(secret) {\n  const bytes = normalizeSecretKey(secret);\n  return nip19.nsecEncode(bytes);\n}\n\n/**\n * Derive hex public key from secret (nsec | hex | Uint8Array)\n */\nexport function derivePubkeyFromSecret(secret) {\n  const bytes = normalizeSecretKey(secret);\n  return getPublicKey(bytes);\n}\n\n/**\n * Convert npub to hex public key\n */\nexport function decodeNpubToHex(npubKey) {\n  if (!isNpubKey(npubKey)) {\n    throw new Error('Invalid npub key');\n  }\n  const decoded = nip19.decode(npubKey);\n  return decoded.data.toLowerCase();\n}\n\n/**\n * Convert hex/Uint8Array public key to npub\n */\nexport function encodePubkeyToNpub(pubkey) {\n  const hex = publicToHex(pubkey);\n  return nip19.npubEncode(hex);\n}\n\n/**\n * Normalize public key to hex string\n */\nexport function publicToHex(pubkey) {\n  if (pubkey instanceof Uint8Array) {\n    return bytesToHex(pubkey);\n  }\n  if (Buffer.isBuffer(pubkey)) {\n    return Buffer.from(pubkey).toString('hex');\n  }\n  if (typeof pubkey === 'string') {\n    if (isNpubKey(pubkey)) {\n      return decodeNpubToHex(pubkey);\n    }\n    if (isHex64(pubkey)) {\n      return pubkey.toLowerCase();\n    }\n  }\n  throw new Error('Unsupported public key format');\n}\n\nexport function isHex64(value) {\n  return typeof value === 'string' && /^[0-9a-fA-F]{64}$/.test(value);\n}\n\nconst keyUtils = {\n  isNsecKey,\n  isNpubKey,\n  decodeNsecToBytes,\n  normalizeSecretKey,\n  secretToHex,\n  encodeSecretToNsec,\n  derivePubkeyFromSecret,\n  decodeNpubToHex,\n  encodePubkeyToNpub,\n  publicToHex,\n  isHex64,\n};\n\nexport default keyUtils;\n","import { finalizeEvent } from 'nostr-tools/pure';\nimport * as nip04 from 'nostr-tools/nip04';\nimport { SimplePool } from 'nostr-tools/pool';\nimport keyUtils from './keyUtils.js';\n\n/**\n * Nostr Client - sends requests to the SDK backend\n */\nclass NostrClient {\n  constructor(options = {}) {\n    this.relayUrls = options.relays || ['wss://dev-relay.lnfi.network'];\n    this.pool = new SimplePool({ enablePing: true, enableReconnect: true });\n    this.privateKey = options.privateKey\n      ? keyUtils.normalizeSecretKey(options.privateKey)\n      : undefined;\n   this.publicKey = options.publicKey\n         ? keyUtils.publicToHex(options.publicKey)\n         : undefined;\n    this.serverPublicKey = options.serverPublicKey\n         ? keyUtils.publicToHex(options.serverPublicKey)\n         : undefined;\n    this.timeout = options.timeout || 30000;\n  }\n\n  /**\n   * Initialize connection (SimplePool manages connections automatically)\n   */\n  async connect() {\n    // SimplePool connects automatically when subscribing; keep method for compatibility\n    console.log(`Client ready to use relays: ${this.relayUrls.join(', ')}`);\n  }\n\n  /**\n   * Send RPC request\n   */\n  async call(method, params = {}) {\n    return new Promise(async (resolve, reject) => {\n      const requestId = `${Date.now()}-${Math.random()}`;\n      const request = { method, params, id: requestId };\n\n      let subscription;\n      let timeoutId;\n      let settled = false;\n\n      const cleanup = () => {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n          timeoutId = null;\n        }\n        if (subscription) {\n          subscription.close();\n          subscription = null;\n        }\n      };\n\n      const finalize = (error, result) => {\n        if (settled) return;\n        settled = true;\n        cleanup();\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      };\n\n      try {\n        const plaintext = JSON.stringify(request);\n        const encrypted = await nip04.encrypt(\n          this.privateKey,\n          this.serverPublicKey,\n          plaintext\n        );\n\n        const event = {\n          kind: 4,\n          pubkey: this.publicKey,\n          created_at: Math.floor(Date.now() / 1000),\n          tags: [['p', this.serverPublicKey]],\n          content: encrypted,\n        };\n\n        const signed = finalizeEvent(event, this.privateKey);\n\n        timeoutId = setTimeout(() => {\n          finalize(new Error(`Request timeout after ${this.timeout}ms`));\n        }, this.timeout);\n\n        subscription = this.pool.subscribe(\n          this.relayUrls,\n          { kinds: [4], '#p': [this.publicKey], authors: [this.serverPublicKey] },\n          {\n            onevent: async (replyEvent) => {\n              if (settled) return;\n\n              const pTag = replyEvent.tags.find(t => t[0] === 'p');\n              if (!pTag || pTag[1] !== this.publicKey || replyEvent.pubkey !== this.serverPublicKey) {\n                return;\n              }\n\n              try {\n                const decrypted = await nip04.decrypt(\n                  this.privateKey,\n                  this.serverPublicKey,\n                  replyEvent.content\n                );\n                const response = JSON.parse(decrypted);\n\n                if (response.id === requestId) {\n                  if (response.error) {\n                    finalize(new Error(response.error));\n                  } else {\n                    finalize(null, response.result);\n                  }\n                }\n              } catch (err) {\n                console.error('Error decrypting reply:', err.message);\n              }\n            },\n          }\n        );\n\n        await Promise.any(this.pool.publish(this.relayUrls, signed));\n\n        console.log(`Sent ${method}`);\n      } catch (error) {\n        finalize(error);\n      }\n    });\n  }\n\n  /**\n   * Send plain text direct message and wait for reply\n   */\n  async sendMessage(text, recipientPubkey, waitForReply = false) {\n    const recipientPubkeyHex = keyUtils.publicToHex(recipientPubkey);\n\n    return new Promise(async (resolve, reject) => {\n      let subscription;\n      let timeoutId;\n      let settled = false;\n\n      const cleanup = () => {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n          timeoutId = null;\n        }\n        if (subscription) {\n          subscription.close();\n          subscription = null;\n        }\n      };\n\n      const finalize = (error, result) => {\n        if (settled) return;\n        settled = true;\n        cleanup();\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      };\n\n      try {\n        const encrypted = await nip04.encrypt(\n          this.privateKey,\n          recipientPubkeyHex,\n          text\n        );\n\n        const event = {\n          kind: 4,\n          pubkey: this.publicKey,\n          created_at: Math.floor(Date.now() / 1000),\n          tags: [['p', recipientPubkeyHex]],\n          content: encrypted,\n        };\n\n        const signed = finalizeEvent(event, this.privateKey);\n        const sentEventId = signed.id;\n        const sentTimestamp = event.created_at;\n\n        if (!waitForReply) {\n          await Promise.any(this.pool.publish(this.relayUrls, signed));\n          console.log(`Message sent to ${recipientPubkeyHex.slice(0, 8)}`);\n          finalize(null, { success: true, timestamp: sentTimestamp, eventId: sentEventId });\n          return;\n        }\n\n        timeoutId = setTimeout(() => {\n          finalize(new Error(`Reply timeout after ${this.timeout}ms`));\n        }, this.timeout);\n\n        subscription = this.pool.subscribe(\n          this.relayUrls,\n          { kinds: [4], '#p': [this.publicKey], authors: [recipientPubkeyHex], since: sentTimestamp },\n          {\n            onevent: async (replyEvent) => {\n              if (settled) return;\n\n              console.log(`[Client] Received reply event ${replyEvent.id.slice(0, 8)} from ${replyEvent.pubkey.slice(0, 8)}`);\n              console.log(`[Client] Event tags:`, replyEvent.tags);\n              console.log(`[Client] Event content:`, replyEvent);\n\n              try {\n                const pTag = replyEvent.tags.find(t => t[0] === 'p');\n                const eTag = replyEvent.tags.find(t => t[0] === 'e');\n                if (!pTag || pTag[1] !== this.publicKey || replyEvent.pubkey !== recipientPubkeyHex) {\n                  console.log(`[Client] Skipping: p or author mismatch`);\n                  return;\n                }\n                if (eTag && eTag[1] !== sentEventId) {\n                  console.log(`[Client] Skipping: e tag mismatch (expected ${sentEventId.slice(0, 8)}, got ${eTag[1].slice(0, 8)})`);\n                  return;\n                }\n                if (!eTag) {\n                  console.log(`[Client] Warning: Reply has no e tag, accepting anyway`);\n                }\n\n                const decrypted = await nip04.decrypt(\n                  this.privateKey,\n                  recipientPubkeyHex,\n                  replyEvent.content\n                );\n\n                finalize(null, {\n                  success: true,\n                  reply: decrypted,\n                  sender: recipientPubkeyHex,\n                  timestamp: replyEvent.created_at,\n                  eventId: replyEvent.id,\n                });\n              } catch (err) {\n                console.error('Error decrypting reply:', err.message);\n              }\n            },\n          }\n        );\n\n        await Promise.any(this.pool.publish(this.relayUrls, signed));\n        console.log(`Message sent to ${recipientPubkeyHex.slice(0, 8)}, waiting for reply...`);\n      } catch (error) {\n        console.error('Error sending message:', error.message);\n        finalize(error);\n      }\n    });\n  }\n\n  /**\n   * Listen for plain text direct messages from a specific sender\n   */\n  listenForMessages(senderPubkey, onMessage, onError) {\n    const senderPubkeyHex = keyUtils.publicToHex(senderPubkey);\n    const subscription = this.pool.subscribe(\n      this.relayUrls,\n      { kinds: [4], '#p': [this.publicKey], authors: [senderPubkeyHex] },\n      {\n        onevent: async (event) => {\n          try {\n            const pTag = event.tags.find(t => t[0] === 'p');\n            if (!pTag || pTag[1] !== this.publicKey || event.pubkey !== senderPubkey) {\n              return;\n            }\n\n            const decrypted = await nip04.decrypt(\n              this.privateKey,\n              senderPubkeyHex,\n              event.content\n            );\n\n            onMessage({\n              text: decrypted,\n              sender: senderPubkey,\n              timestamp: event.created_at,\n              eventId: event.id,\n            });\n          } catch (err) {\n            console.error('Error decrypting message:', err.message);\n            if (onError) onError(err);\n          }\n        },\n      }\n    );\n\n    return subscription;\n  }\n\n  /**\n   * Close connections\n   */\n  close() {\n    this.pool.close(this.relayUrls);\n  }\n}\n\nexport default NostrClient;\n","import { finalizeEvent } from 'nostr-tools/pure';\nimport * as nip04 from 'nostr-tools/nip04';\nimport { SimplePool } from 'nostr-tools/pool';\nimport { EventEmitter } from 'events';\nimport keyUtils from './keyUtils.js';\n\n/**\n * Create default memory-based event storage adapter\n */\nfunction createMemoryQueue() {\n  const queue = [];\n  let idCounter = 0;\n\n  return {\n    async enqueue(event) {\n      const storageId = `mem_${Date.now()}_${idCounter++}`;\n      queue.push({ storageId, event });\n      return storageId;\n    },\n    async dequeueBatch(limit) {\n      return queue.splice(0, limit);\n    },\n    async ack(storageId, meta) {\n      // Memory queue auto-removes on dequeue, no-op for ack\n    },\n    async size() {\n      return queue.length;\n    },\n  };\n}\n\n/**\n * Nostr SDK - Backend server\n * Listen for direct messages, parse JSON-RPC style requests, call business methods, and return results\n * Supports immediate and queued processing modes with dynamic whitelist management\n */\nclass NostrSdk extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.relayUrls = options.relays || ['wss://dev-relay.lnfi.network'];\n    this.pool = new SimplePool({ enablePing: true, enableReconnect: true });\n    this.privateKey = options.privateKey\n      ? keyUtils.normalizeSecretKey(options.privateKey)\n      : undefined;\n    this.publicKey = options.publicKey\n      ? keyUtils.publicToHex(options.publicKey)\n      : undefined;\n\n    // Processing mode: 'immediate' or 'queued'\n    this.processingMode = options.processingMode || 'immediate';\n    \n    // Event storage adapter (default: memory queue)\n    this.eventStorage = options.eventStorage || createMemoryQueue();\n    \n    // Processing rate (events per second, max 3 due to relay limits)\n    this.processingRate = Math.min(options.processingRate || 3, 3);\n    \n    // Event processing timeout (default 30 seconds)\n    this.eventTimeout = options.eventTimeout || 30000;\n    \n    // Internal whitelist array (initialized from allowedAuthors)\n    this._authorWhitelist = Array.isArray(options.allowedAuthors)\n      ? options.allowedAuthors.map(keyUtils.publicToHex)\n      : [];\n    \n    // Custom whitelist getter (takes precedence over internal array)\n    this._customGetAuthorWhitelist = options.getAuthorWhitelist;\n    \n    // Method registry: Map<methodName, { handler, authConfig }>\n    this.methodRegistry = new Map();\n    \n    this.isListening = false;\n    this.subscription = null;\n    this.queueTimer = null;\n    this._isProcessing = false;\n  }\n\n  /**\n   * Register business methods with optional auth configuration\n   * @param {string} method - Method name\n   * @param {Function} handler - Handler function\n   * @param {Object} authConfig - Optional auth config { authMode, whitelist, authHandler }\n   */\n  registerMethod(method, handler, authConfig = {}) {\n    if (typeof handler !== 'function') {\n      throw new Error(`Handler for method \"${method}\" must be a function`);\n    }\n    this.methodRegistry.set(method, {\n      handler,\n      authConfig: {\n        authMode: authConfig.authMode || 'public',\n        whitelist: authConfig.whitelist || null,\n        authHandler: authConfig.authHandler || null,\n      },\n    });\n  }\n\n  /**\n   * Get current author whitelist (supports custom implementation)\n   * @returns {Promise<string[]|null>} Whitelist array or null (no restriction)\n   */\n  async getAuthorWhitelist() {\n    if (this._customGetAuthorWhitelist) {\n      const result = this._customGetAuthorWhitelist();\n      return result instanceof Promise ? await result : result;\n    }\n    return this._authorWhitelist.length > 0 ? this._authorWhitelist : null;\n  }\n\n  /**\n   * Add pubkeys to internal whitelist\n   */\n  addToWhitelist(...pubkeys) {\n    const normalized = pubkeys.map(keyUtils.publicToHex);\n    this._authorWhitelist.push(...normalized.filter(pk => !this._authorWhitelist.includes(pk)));\n  }\n\n  /**\n   * Remove pubkeys from internal whitelist\n   */\n  removeFromWhitelist(...pubkeys) {\n    const normalized = pubkeys.map(keyUtils.publicToHex);\n    this._authorWhitelist = this._authorWhitelist.filter(pk => !normalized.includes(pk));\n  }\n\n  /**\n   * Clear internal whitelist\n   */\n  clearWhitelist() {\n    this._authorWhitelist = [];\n  }\n\n  /**\n   * Check if pubkey is in current whitelist\n   */\n  async isInWhitelist(pubkey) {\n    const whitelist = await this.getAuthorWhitelist();\n    if (!whitelist || whitelist.length === 0) return true;\n    return whitelist.includes(keyUtils.publicToHex(pubkey));\n  }\n\n  /**\n   * Start listening\n   */\n  async start() {\n    if (this.isListening) {\n      console.log('Already listening for messages');\n      return;\n    }\n\n    if (!this.privateKey || !this.publicKey) {\n      throw new Error('privateKey and publicKey are required');\n    }\n\n    this.isListening = true;\n    console.log(`Starting Nostr SDK on relays: ${this.relayUrls.join(', ')}`);\n\n    // Subscribe to direct message events (kind 4)\n    // Note: No filter.authors - dynamic whitelist check in _handleEvent\n    const filter = {\n      kinds: [4],\n      since: Math.floor(Date.now() / 1000),\n      '#p': [this.publicKey],\n    };\n\n    this.subscription = this.pool.subscribe(\n      this.relayUrls,\n      filter,\n      {\n        onevent: (event) => this._handleEvent(event),\n      }\n    );\n\n    // Start queue processor for queued mode\n    if (this.processingMode === 'queued') {\n      this._startQueueProcessor();\n    }\n\n    console.log(`Subscribed to all relays (mode: ${this.processingMode})`);\n    this.emit('started');\n  }\n\n  /**\n   * Start queue processor timer\n   */\n  _startQueueProcessor() {\n    const intervalMs = Math.floor(1000 / this.processingRate);\n    this.queueTimer = setInterval(() => this._processQueue(), intervalMs);\n  }\n\n  /**\n   * Process queued events in batches with timeout and parallel execution\n   */\n  async _processQueue() {\n    // Prevent concurrent batch processing\n    if (this._isProcessing) return;\n    \n    this._isProcessing = true;\n    try {\n      const batchSize = Math.max(1, this.processingRate);\n      const items = await this.eventStorage.dequeueBatch(batchSize);\n\n      if (items.length === 0) return;\n\n      // Process items in parallel with timeout\n      const results = await Promise.allSettled(\n        items.map(item => this._processWithTimeout(item))\n      );\n\n      // Ack based on results\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n        const result = results[i];\n        \n        if (result.status === 'fulfilled') {\n          await this.eventStorage.ack(item.storageId, { status: 'success' });\n        } else {\n          const error = result.reason?.message || 'Unknown error';\n          console.error(`Error processing ${item.storageId}:`, error);\n          await this.eventStorage.ack(item.storageId, { \n            status: 'failed', \n            error \n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error in queue processor:', error.message);\n    } finally {\n      this._isProcessing = false;\n    }\n  }\n\n  /**\n   * Process event with timeout wrapper\n   */\n  async _processWithTimeout(item) {\n    let timeoutHandle;\n    \n    const timeoutPromise = new Promise((_, reject) => {\n      timeoutHandle = setTimeout(\n        () => reject(new Error('Event processing timeout')), \n        this.eventTimeout\n      );\n    });\n    \n    try {\n      const result = await Promise.race([\n        this._processStoredEvent(item),\n        timeoutPromise\n      ]);\n      return result;\n    } finally {\n      // Clear timeout to prevent memory leak\n      if (timeoutHandle) clearTimeout(timeoutHandle);\n    }\n  }\n\n  /**\n   * Process a single stored event from queue\n   */\n  async _processStoredEvent(item) {\n    const { event } = item;\n\n    // Re-check global whitelist (may have changed since enqueue)\n    const whitelist = await this.getAuthorWhitelist();\n    if (whitelist && whitelist.length > 0 && !whitelist.includes(event.pubkey)) {\n      // Throw error to prevent outer ack from overwriting failure status\n      throw new Error('sender_not_allowed');\n    }\n\n    // Decrypt and process (same as immediate mode)\n    await this._processDecryptedEvent(event);\n  }\n\n  /**\n   * Handle received events (entry point)\n   */\n  async _handleEvent(event) {\n    try {\n      // 1. Check if message is for us (p-tag validation)\n      const pTag = event.tags.find(t => t[0] === 'p');\n      if (!pTag || pTag[1] !== this.publicKey) {\n        return;\n      }\n\n      // 2. Global whitelist pre-filter\n      const whitelist = await this.getAuthorWhitelist();\n      if (whitelist && whitelist.length > 0 && !whitelist.includes(event.pubkey)) {\n        console.log(`[SDK] Sender ${event.pubkey.slice(0, 8)} not in whitelist`);\n        return;\n      }\n\n      // 3. Route based on processing mode\n      if (this.processingMode === 'immediate') {\n        await this._processDecryptedEvent(event);\n      } else {\n        // Queued mode: store event for later processing\n        await this._storeEvent(event);\n      }\n    } catch (error) {\n      console.error('Error in _handleEvent:', error.message);\n    }\n  }\n\n  /**\n   * Store event to queue (queued mode only)\n   */\n  async _storeEvent(event) {\n    try {\n      const storageId = await this.eventStorage.enqueue(event);\n      console.log(`[SDK] Event ${event.id?.slice(0, 8)} queued as ${storageId}`);\n    } catch (error) {\n      console.error('Error storing event:', error.message);\n    }\n  }\n\n  /**\n   * Process decrypted event (shared by immediate and queued modes)\n   */\n  async _processDecryptedEvent(event) {\n    try {\n      // Decrypt direct message content\n      const decrypted = await nip04.decrypt(this.privateKey, event.pubkey, event.content);\n\n      // Parse JSON request\n      let request;\n      try {\n        request = JSON.parse(decrypted);\n      } catch (e) {\n        await this._replyError(event.pubkey, 'Invalid JSON format', null);\n        return;\n      }\n\n      // Validate request format\n      if (!request.method) {\n        await this._replyError(event.pubkey, 'Missing method field', null);\n        return;\n      }\n\n      // Get method handler and auth config\n      const methodEntry = this.methodRegistry.get(request.method);\n      if (!methodEntry) {\n        await this._replyError(event.pubkey, `Method not found: ${request.method}`, request.id);\n        return;\n      }\n\n      // Check method-level permissions\n      const hasPermission = await this._checkPermission(request.method, event.pubkey, methodEntry.authConfig);\n      if (!hasPermission) {\n        await this._replyError(event.pubkey, `Permission denied for method: ${request.method}`, request.id);\n        return;\n      }\n\n      // Call handler with enhanced parameters\n      const result = await methodEntry.handler(\n        request.params || {}, \n        event, \n        event.id, \n        event.pubkey\n      );\n\n      // Return result\n      await this._reply(event.pubkey, {\n        id: request.id,\n        result,\n        error: null,\n      });\n    } catch (error) {\n      console.error('Error processing decrypted event:', error.message);\n    }\n  }\n\n  /**\n   * Check method-level permissions\n   */\n  async _checkPermission(methodName, senderPubkey, authConfig) {\n    const { authMode, whitelist, authHandler } = authConfig;\n\n    // Public mode: always allow\n    if (authMode === 'public') {\n      return true;\n    }\n\n    // Whitelist mode: check method-level or global whitelist\n    if (authMode === 'whitelist') {\n      if (whitelist && whitelist.length > 0) {\n        return whitelist.includes(senderPubkey);\n      }\n      // Fallback to global whitelist\n      return await this.isInWhitelist(senderPubkey);\n    }\n\n    // Custom mode: call custom auth handler\n    if (authMode === 'custom' && authHandler) {\n      return await authHandler(senderPubkey);\n    }\n\n    return false;\n  }\n\n  /**\n   * Send direct message reply\n   */\n  async _reply(recipientPubkey, data) {\n    try {\n      const plaintext = JSON.stringify(data);\n      const encrypted = await nip04.encrypt(this.privateKey, recipientPubkey, plaintext);\n\n      const event = {\n        kind: 4,\n        pubkey: this.publicKey,\n        created_at: Math.floor(Date.now() / 1000),\n        tags: [['p', recipientPubkey]],\n        content: encrypted,\n      };\n\n      const signed = finalizeEvent(event, this.privateKey);\n\n      // Use SimplePool to publish to all relays\n      await Promise.any(this.pool.publish(this.relayUrls, signed));\n\n      console.log(`Replied to ${recipientPubkey.slice(0, 8)}`);\n    } catch (error) {\n      console.error('Error sending reply:', error.message);\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Send error reply\n   */\n  async _replyError(recipientPubkey, message, requestId) {\n    await this._reply(recipientPubkey, {\n      id: requestId,\n      result: null,\n      error: message,\n    });\n  }\n\n  /**\n   * Stop listening and cleanup resources\n   */\n  stop() {\n    this.isListening = false;\n\n    // Clear queue processor timer\n    if (this.queueTimer) {\n      clearInterval(this.queueTimer);\n      this.queueTimer = null;\n    }\n\n    // Close subscription\n    if (this.subscription) {\n      this.subscription.close();\n      this.subscription = null;\n    }\n\n    // Close SimplePool\n    this.pool.close(this.relayUrls);\n\n    console.log('SDK stopped');\n    this.emit('stopped');\n  }\n}\n\nexport default NostrSdk;","import NostrClient from './src/nostrClient.js';\nimport NostrSdk from './src/nostrSdk.js';\nimport keyUtils from './src/keyUtils.js';\n\nimport * as nip04 from 'nostr-tools/nip04';\nimport * as nip19 from 'nostr-tools/nip19';\nimport { SimplePool, useWebSocketImplementation } from 'nostr-tools/pool';\nimport {\n  finalizeEvent,\n  verifyEvent,\n  generateSecretKey,\n  getPublicKey,\n} from 'nostr-tools/pure';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\n\nconst api = {\n  NostrClient,\n  NostrSdk,\n  nip04,\n  nip19,\n  SimplePool,\n  useWebSocketImplementation,\n  finalizeEvent,\n  verifyEvent,\n  generateSecretKey,\n  getPublicKey,\n  bytesToHex,\n  hexToBytes,\n  keyUtils,\n};\n\nexport {\n  NostrClient,\n  NostrSdk,\n  nip04,\n  nip19,\n  SimplePool,\n  useWebSocketImplementation,\n  finalizeEvent,\n  verifyEvent,\n  generateSecretKey,\n  getPublicKey,\n  bytesToHex,\n  hexToBytes,\n  keyUtils,\n};\n\nexport default api;\n"],"names":["isNsecKey","value","isNpubKey","decodeNsecToBytes","nsecKey","nip19","normalizeSecretKey","secret","isHex64","hexToBytes","secretToHex","bytes","bytesToHex","encodeSecretToNsec","derivePubkeyFromSecret","getPublicKey","decodeNpubToHex","npubKey","encodePubkeyToNpub","pubkey","hex","publicToHex","keyUtils","NostrClient","options","SimplePool","method","params","resolve","reject","requestId","request","subscription","timeoutId","settled","cleanup","finalize","error","result","plaintext","encrypted","nip04","event","signed","finalizeEvent","replyEvent","pTag","t","decrypted","response","err","text","recipientPubkey","waitForReply","recipientPubkeyHex","sentEventId","sentTimestamp","eTag","senderPubkey","onMessage","onError","senderPubkeyHex","createMemoryQueue","queue","idCounter","storageId","limit","meta","NostrSdk","EventEmitter","handler","authConfig","pubkeys","normalized","pk","whitelist","filter","intervalMs","batchSize","items","results","item","i","_a","timeoutHandle","timeoutPromise","_","methodEntry","methodName","authMode","authHandler","data","message","api","useWebSocketImplementation","verifyEvent","generateSecretKey"],"mappings":"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"}