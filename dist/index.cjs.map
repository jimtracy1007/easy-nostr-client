{"version":3,"file":"index.cjs","sources":["../src/keyUtils.js","../src/nostrClient.js","../src/nostrSdk.js","../index.js"],"sourcesContent":["import { getPublicKey } from 'nostr-tools/pure';\nimport * as nip19 from 'nostr-tools/nip19';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\n\n/**\n * Determine if a value is an nsec (NIP-19 secret key)\n */\nexport function isNsecKey(value) {\n  return typeof value === 'string' && value.startsWith('nsec1');\n}\n\n/**\n * Determine if a value is an npub (NIP-19 public key)\n */\nexport function isNpubKey(value) {\n  return typeof value === 'string' && value.startsWith('npub1');\n}\n\n/**\n * Convert nsec to Uint8Array\n */\nexport function decodeNsecToBytes(nsecKey) {\n  if (!isNsecKey(nsecKey)) {\n    throw new Error('Invalid nsec key');\n  }\n  const decoded = nip19.decode(nsecKey);\n  return decoded.data;\n}\n\n/**\n * Convert secret key (nsec | hex | Uint8Array) to Uint8Array\n */\nexport function normalizeSecretKey(secret) {\n  if (secret instanceof Uint8Array) {\n    return secret;\n  }\n  if (Buffer.isBuffer(secret)) {\n    return Uint8Array.from(secret);\n  }\n  if (typeof secret === 'string') {\n    if (isNsecKey(secret)) {\n      return decodeNsecToBytes(secret);\n    }\n    if (isHex64(secret)) {\n      return hexToBytes(secret);\n    }\n  }\n  throw new Error('Unsupported secret key format');\n}\n\n/**\n * Convert Uint8Array/Buffer/hex secret key to hex string\n */\nexport function secretToHex(secret) {\n  const bytes = normalizeSecretKey(secret);\n  return bytesToHex(bytes);\n}\n\n/**\n * Convert secret key to nsec string\n */\nexport function encodeSecretToNsec(secret) {\n  const bytes = normalizeSecretKey(secret);\n  return nip19.nsecEncode(bytes);\n}\n\n/**\n * Derive hex public key from secret (nsec | hex | Uint8Array)\n */\nexport function derivePubkeyFromSecret(secret) {\n  const bytes = normalizeSecretKey(secret);\n  return getPublicKey(bytes);\n}\n\n/**\n * Convert npub to hex public key\n */\nexport function decodeNpubToHex(npubKey) {\n  if (!isNpubKey(npubKey)) {\n    throw new Error('Invalid npub key');\n  }\n  const decoded = nip19.decode(npubKey);\n  return decoded.data.toLowerCase();\n}\n\n/**\n * Convert hex/Uint8Array public key to npub\n */\nexport function encodePubkeyToNpub(pubkey) {\n  const hex = publicToHex(pubkey);\n  return nip19.npubEncode(hex);\n}\n\n/**\n * Normalize public key to hex string\n */\nexport function publicToHex(pubkey) {\n  if (pubkey instanceof Uint8Array) {\n    return bytesToHex(pubkey);\n  }\n  if (Buffer.isBuffer(pubkey)) {\n    return Buffer.from(pubkey).toString('hex');\n  }\n  if (typeof pubkey === 'string') {\n    if (isNpubKey(pubkey)) {\n      return decodeNpubToHex(pubkey);\n    }\n    if (isHex64(pubkey)) {\n      return pubkey.toLowerCase();\n    }\n  }\n  throw new Error('Unsupported public key format');\n}\n\nexport function isHex64(value) {\n  return typeof value === 'string' && /^[0-9a-fA-F]{64}$/.test(value);\n}\n\nconst keyUtils = {\n  isNsecKey,\n  isNpubKey,\n  decodeNsecToBytes,\n  normalizeSecretKey,\n  secretToHex,\n  encodeSecretToNsec,\n  derivePubkeyFromSecret,\n  decodeNpubToHex,\n  encodePubkeyToNpub,\n  publicToHex,\n  isHex64,\n};\n\nexport default keyUtils;\n","import { finalizeEvent } from 'nostr-tools/pure';\nimport * as nip04 from 'nostr-tools/nip04';\nimport { SimplePool } from 'nostr-tools/pool';\nimport keyUtils from './keyUtils.js';\n\n/**\n * Nostr Client - sends requests to the SDK backend\n */\nclass NostrClient {\n  constructor(options = {}) {\n    this.relayUrls = options.relays || ['wss://dev-relay.lnfi.network'];\n    this.pool = new SimplePool({ enablePing: true, enableReconnect: true });\n    this.privateKey = options.privateKey\n      ? keyUtils.normalizeSecretKey(options.privateKey)\n      : undefined;\n   this.publicKey = options.publicKey\n         ? keyUtils.publicToHex(options.publicKey)\n         : undefined;\n    this.serverPublicKey = options.serverPublicKey\n         ? keyUtils.publicToHex(options.serverPublicKey)\n         : undefined;\n    this.additionalTags = Array.isArray(options.tags) ? options.tags : [];\n    this.replyFilterBuilder = this._validateFilterBuilder(options.replyFilter);\n    this.messageReplyFilterBuilder = this._validateFilterBuilder(\n      options.messageReplyFilter || options.replyFilter\n    );\n    this.incomingFilterBuilder = this._validateFilterBuilder(options.incomingFilter);\n    this.timeout = options.timeout || 30000;\n  }\n\n  setTags(tags = []) {\n    if (!Array.isArray(tags)) {\n      throw new Error('tags must be an array');\n    }\n    this.additionalTags = tags;\n  }\n\n  setReplyFilter(builder) {\n    this.replyFilterBuilder = this._validateFilterBuilder(builder);\n  }\n\n  setMessageReplyFilter(builder) {\n    this.messageReplyFilterBuilder = this._validateFilterBuilder(builder);\n  }\n\n  setIncomingFilter(builder) {\n    this.incomingFilterBuilder = this._validateFilterBuilder(builder);\n  }\n\n  _validateFilterBuilder(builder) {\n    if (builder == null) {\n      return null;\n    }\n    if (typeof builder !== 'function') {\n      throw new Error('Filter override must be a function accepting (baseFilter, context)');\n    }\n    return builder;\n  }\n\n  _buildFilter(baseFilter, builder, context) {\n    const draft = { ...baseFilter };\n    if (!builder) {\n      return draft;\n    }\n    const result = builder({ ...draft }, context) || draft;\n    if (typeof result !== 'object' || result === null) {\n      throw new Error('Filter builder must return an object');\n    }\n    return result;\n  }\n\n  /**\n   * Initialize connection (SimplePool manages connections automatically)\n   */\n  async connect() {\n    // SimplePool connects automatically when subscribing; keep method for compatibility\n    console.log(`Client ready to use relays: ${this.relayUrls.join(', ')}`);\n  }\n\n  /**\n   * Send RPC request\n   */\n  async call(method, params = {}) {\n    return new Promise(async (resolve, reject) => {\n      const requestId = `${Date.now()}-${Math.random()}`;\n      const request = { method, params, id: requestId };\n\n      let subscription;\n      let timeoutId;\n      let settled = false;\n\n      const cleanup = () => {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n          timeoutId = null;\n        }\n        if (subscription) {\n          subscription.close();\n          subscription = null;\n        }\n      };\n\n      const finalize = (error, result) => {\n        if (settled) return;\n        settled = true;\n        cleanup();\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      };\n\n      try {\n        const plaintext = JSON.stringify(request);\n        const encrypted = await nip04.encrypt(\n          this.privateKey,\n          this.serverPublicKey,\n          plaintext\n        );\n\n        const event = {\n          kind: 4,\n          pubkey: this.publicKey,\n          created_at: Math.floor(Date.now() / 1000),\n          tags: [['p', this.serverPublicKey], ...this.additionalTags],\n          content: encrypted,\n        };\n\n        const signed = finalizeEvent(event, this.privateKey);\n\n        timeoutId = setTimeout(() => {\n          finalize(new Error(`Request timeout after ${this.timeout}ms`));\n        }, this.timeout);\n\n        const baseFilter = {\n          kinds: [4],\n          '#p': [this.publicKey],\n          authors: [this.serverPublicKey],\n        };\n        const filter = this._buildFilter(baseFilter, this.replyFilterBuilder, {\n          method,\n          params,\n          requestId,\n        });\n\n        subscription = this.pool.subscribe(\n          this.relayUrls,\n          filter,\n          {\n            onevent: async (replyEvent) => {\n              if (settled) return;\n\n              const pTag = replyEvent.tags.find(t => t[0] === 'p');\n              if (!pTag || pTag[1] !== this.publicKey || replyEvent.pubkey !== this.serverPublicKey) {\n                return;\n              }\n\n              try {\n                const decrypted = await nip04.decrypt(\n                  this.privateKey,\n                  this.serverPublicKey,\n                  replyEvent.content\n                );\n                const response = JSON.parse(decrypted);\n\n                if (response.id === requestId) {\n                  if (response.error) {\n                    finalize(new Error(response.error));\n                  } else {\n                    finalize(null, response.result);\n                  }\n                }\n              } catch (err) {\n                console.error('Error decrypting reply:', err.message);\n              }\n            },\n          }\n        );\n\n        await Promise.any(this.pool.publish(this.relayUrls, signed));\n\n        console.log(`Sent ${method}`);\n      } catch (error) {\n        finalize(error);\n      }\n    });\n  }\n\n  /**\n   * Send plain text direct message and wait for reply\n   */\n  async sendMessage(text, recipientPubkey, waitForReply = false) {\n    const recipientPubkeyHex = keyUtils.publicToHex(recipientPubkey);\n\n    return new Promise(async (resolve, reject) => {\n      let subscription;\n      let timeoutId;\n      let settled = false;\n\n      const cleanup = () => {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n          timeoutId = null;\n        }\n        if (subscription) {\n          subscription.close();\n          subscription = null;\n        }\n      };\n\n      const finalize = (error, result) => {\n        if (settled) return;\n        settled = true;\n        cleanup();\n        if (error) {\n          reject(error);\n        } else {\n          resolve(result);\n        }\n      };\n\n      try {\n        const encrypted = await nip04.encrypt(\n          this.privateKey,\n          recipientPubkeyHex,\n          text\n        );\n\n        const event = {\n          kind: 4,\n          pubkey: this.publicKey,\n          created_at: Math.floor(Date.now() / 1000),\n          tags: [['p', recipientPubkeyHex], ...this.additionalTags],\n          content: encrypted,\n        };\n\n        const signed = finalizeEvent(event, this.privateKey);\n        const sentEventId = signed.id;\n        const sentTimestamp = event.created_at;\n\n        if (!waitForReply) {\n          await Promise.any(this.pool.publish(this.relayUrls, signed));\n          console.log(`Message sent to ${recipientPubkeyHex.slice(0, 8)}`);\n          finalize(null, { success: true, timestamp: sentTimestamp, eventId: sentEventId });\n          return;\n        }\n\n        timeoutId = setTimeout(() => {\n          finalize(new Error(`Reply timeout after ${this.timeout}ms`));\n        }, this.timeout);\n\n        const baseFilter = {\n          kinds: [4],\n          '#p': [this.publicKey],\n          authors: [recipientPubkeyHex],\n          since: sentTimestamp,\n        };\n        const filter = this._buildFilter(baseFilter, this.messageReplyFilterBuilder, {\n          recipientPubkey: recipientPubkeyHex,\n          sentEventId,\n          sentTimestamp,\n        });\n\n        subscription = this.pool.subscribe(\n          this.relayUrls,\n          filter,\n          {\n            onevent: async (replyEvent) => {\n              if (settled) return;\n\n              console.log(`[Client] Received reply event ${replyEvent.id.slice(0, 8)} from ${replyEvent.pubkey.slice(0, 8)}`);\n              console.log(`[Client] Event tags:`, replyEvent.tags);\n              console.log(`[Client] Event content:`, replyEvent);\n\n              try {\n                const pTag = replyEvent.tags.find(t => t[0] === 'p');\n                const eTag = replyEvent.tags.find(t => t[0] === 'e');\n                if (!pTag || pTag[1] !== this.publicKey || replyEvent.pubkey !== recipientPubkeyHex) {\n                  console.log(`[Client] Skipping: p or author mismatch`);\n                  return;\n                }\n                if (eTag && eTag[1] !== sentEventId) {\n                  console.log(`[Client] Skipping: e tag mismatch (expected ${sentEventId.slice(0, 8)}, got ${eTag[1].slice(0, 8)})`);\n                  return;\n                }\n                if (!eTag) {\n                  console.log(`[Client] Warning: Reply has no e tag, accepting anyway`);\n                }\n\n                const decrypted = await nip04.decrypt(\n                  this.privateKey,\n                  recipientPubkeyHex,\n                  replyEvent.content\n                );\n\n                finalize(null, {\n                  success: true,\n                  reply: decrypted,\n                  sender: recipientPubkeyHex,\n                  timestamp: replyEvent.created_at,\n                  eventId: replyEvent.id,\n                });\n              } catch (err) {\n                console.error('Error decrypting reply:', err.message);\n              }\n            },\n          }\n        );\n\n        await Promise.any(this.pool.publish(this.relayUrls, signed));\n        console.log(`Message sent to ${recipientPubkeyHex.slice(0, 8)}, waiting for reply...`);\n      } catch (error) {\n        console.error('Error sending message:', error.message);\n        finalize(error);\n      }\n    });\n  }\n\n  /**\n   * Listen for plain text direct messages from a specific sender\n   */\n  listenForMessages(senderPubkey, onMessage, onError) {\n    const senderPubkeyHex = keyUtils.publicToHex(senderPubkey);\n    const baseFilter = {\n      kinds: [4],\n      '#p': [this.publicKey],\n      authors: [senderPubkeyHex],\n    };\n    const filter = this._buildFilter(baseFilter, this.incomingFilterBuilder, {\n      senderPubkey: senderPubkeyHex,\n    });\n\n    const subscription = this.pool.subscribe(\n      this.relayUrls,\n      filter,\n      {\n        onevent: async (event) => {\n          try {\n            const pTag = event.tags.find(t => t[0] === 'p');\n            if (!pTag || pTag[1] !== this.publicKey || event.pubkey !== senderPubkey) {\n              return;\n            }\n\n            const decrypted = await nip04.decrypt(\n              this.privateKey,\n              senderPubkeyHex,\n              event.content\n            );\n\n            onMessage({\n              text: decrypted,\n              sender: senderPubkey,\n              timestamp: event.created_at,\n              eventId: event.id,\n            });\n          } catch (err) {\n            console.error('Error decrypting message:', err.message);\n            if (onError) onError(err);\n          }\n        },\n      }\n    );\n\n    return subscription;\n  }\n\n  /**\n   * Close connections\n   */\n  close() {\n    this.pool.close(this.relayUrls);\n  }\n}\n\nexport default NostrClient;\n","import { finalizeEvent } from 'nostr-tools/pure';\nimport * as nip04 from 'nostr-tools/nip04';\nimport { SimplePool } from 'nostr-tools/pool';\nimport { EventEmitter } from 'events';\nimport keyUtils from './keyUtils.js';\n\n/**\n * Create default memory-based event storage adapter\n */\nfunction createMemoryQueue() {\n  const queue = [];\n  let idCounter = 0;\n\n  return {\n    async enqueue(event) {\n      const storageId = `mem_${Date.now()}_${idCounter++}`;\n      queue.push({ storageId, event });\n      return storageId;\n    },\n    async dequeueBatch(limit) {\n      return queue.splice(0, limit);\n    },\n    async ack(storageId, meta) {\n      // Memory queue auto-removes on dequeue, no-op for ack\n    },\n    async size() {\n      return queue.length;\n    },\n  };\n}\n\n/**\n * Nostr SDK - Backend server\n * Listen for direct messages, parse JSON-RPC style requests, call business methods, and return results\n * Supports immediate and queued processing modes with dynamic whitelist management\n */\nclass NostrSdk extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.relayUrls = options.relays || ['wss://dev-relay.lnfi.network'];\n    this.pool = new SimplePool({ enablePing: true, enableReconnect: true });\n    this.privateKey = options.privateKey\n      ? keyUtils.normalizeSecretKey(options.privateKey)\n      : undefined;\n    this.publicKey = options.publicKey\n      ? keyUtils.publicToHex(options.publicKey)\n      : undefined;\n\n    // Processing mode: 'immediate' or 'queued'\n    this.processingMode = options.processingMode || 'immediate';\n    \n    // Event storage adapter (default: memory queue)\n    this.eventStorage = options.eventStorage || createMemoryQueue();\n    \n    // Processing rate (events per second, max 3 due to relay limits)\n    this.processingRate = Math.min(options.processingRate || 3, 3);\n    \n    // Event processing timeout (default 30 seconds)\n    this.eventTimeout = options.eventTimeout || 30000;\n    \n    // Internal whitelist array (initialized from allowedAuthors)\n    this._authorWhitelist = Array.isArray(options.allowedAuthors)\n      ? options.allowedAuthors.map(keyUtils.publicToHex)\n      : [];\n    \n    // Custom whitelist getter (takes precedence over internal array)\n    this._customGetAuthorWhitelist = options.getAuthorWhitelist;\n    \n    // Method registry: Map<methodName, { handler, authConfig }>\n    this.methodRegistry = new Map();\n    \n    this.isListening = false;\n    this.subscription = null;\n    this.queueTimer = null;\n    this._isProcessing = false;\n  }\n\n  /**\n   * Register business methods with optional auth configuration\n   * @param {string} method - Method name\n   * @param {Function} handler - Handler function\n   * @param {Object} authConfig - Optional auth config { authMode, whitelist, authHandler }\n   */\n  registerMethod(method, handler, authConfig = {}) {\n    if (typeof handler !== 'function') {\n      throw new Error(`Handler for method \"${method}\" must be a function`);\n    }\n    this.methodRegistry.set(method, {\n      handler,\n      authConfig: {\n        authMode: authConfig.authMode || 'public',\n        whitelist: authConfig.whitelist || null,\n        authHandler: authConfig.authHandler || null,\n      },\n    });\n  }\n\n  /**\n   * Get current author whitelist (supports custom implementation)\n   * @returns {Promise<string[]|null>} Whitelist array or null (no restriction)\n   */\n  async getAuthorWhitelist() {\n    if (this._customGetAuthorWhitelist) {\n      const result = this._customGetAuthorWhitelist();\n      return result instanceof Promise ? await result : result;\n    }\n    return this._authorWhitelist.length > 0 ? this._authorWhitelist : null;\n  }\n\n  /**\n   * Add pubkeys to internal whitelist\n   */\n  addToWhitelist(...pubkeys) {\n    const normalized = pubkeys.map(keyUtils.publicToHex);\n    this._authorWhitelist.push(...normalized.filter(pk => !this._authorWhitelist.includes(pk)));\n  }\n\n  /**\n   * Remove pubkeys from internal whitelist\n   */\n  removeFromWhitelist(...pubkeys) {\n    const normalized = pubkeys.map(keyUtils.publicToHex);\n    this._authorWhitelist = this._authorWhitelist.filter(pk => !normalized.includes(pk));\n  }\n\n  /**\n   * Clear internal whitelist\n   */\n  clearWhitelist() {\n    this._authorWhitelist = [];\n  }\n\n  /**\n   * Check if pubkey is in current whitelist\n   */\n  async isInWhitelist(pubkey) {\n    const whitelist = await this.getAuthorWhitelist();\n    if (!whitelist || whitelist.length === 0) return true;\n    return whitelist.includes(keyUtils.publicToHex(pubkey));\n  }\n\n  /**\n   * Start listening\n   */\n  async start() {\n    if (this.isListening) {\n      console.log('Already listening for messages');\n      return;\n    }\n\n    if (!this.privateKey || !this.publicKey) {\n      throw new Error('privateKey and publicKey are required');\n    }\n\n    this.isListening = true;\n    console.log(`Starting Nostr SDK on relays: ${this.relayUrls.join(', ')}`);\n\n    // Subscribe to direct message events (kind 4)\n    // Note: No filter.authors - dynamic whitelist check in _handleEvent\n    const filter = {\n      kinds: [4],\n      since: Math.floor(Date.now() / 1000),\n      '#p': [this.publicKey],\n    };\n\n    this.subscription = this.pool.subscribe(\n      this.relayUrls,\n      filter,\n      {\n        onevent: (event) => this._handleEvent(event),\n      }\n    );\n\n    // Start queue processor for queued mode\n    if (this.processingMode === 'queued') {\n      this._startQueueProcessor();\n    }\n\n    console.log(`Subscribed to all relays (mode: ${this.processingMode})`);\n    this.emit('started');\n  }\n\n  /**\n   * Start queue processor timer\n   */\n  _startQueueProcessor() {\n    const intervalMs = Math.floor(1000 / this.processingRate);\n    this.queueTimer = setInterval(() => this._processQueue(), intervalMs);\n  }\n\n  /**\n   * Process queued events in batches with timeout and parallel execution\n   */\n  async _processQueue() {\n    // Prevent concurrent batch processing\n    if (this._isProcessing) return;\n    \n    this._isProcessing = true;\n    try {\n      const batchSize = Math.max(1, this.processingRate);\n      const items = await this.eventStorage.dequeueBatch(batchSize);\n\n      if (items.length === 0) return;\n\n      // Process items in parallel with timeout\n      const results = await Promise.allSettled(\n        items.map(item => this._processWithTimeout(item))\n      );\n\n      // Ack based on results\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n        const result = results[i];\n        \n        if (result.status === 'fulfilled') {\n          await this.eventStorage.ack(item.storageId, { status: 'success' });\n        } else {\n          const error = result.reason?.message || 'Unknown error';\n          console.error(`Error processing ${item.storageId}:`, error);\n          await this.eventStorage.ack(item.storageId, { \n            status: 'failed', \n            error \n          });\n        }\n      }\n    } catch (error) {\n      console.error('Error in queue processor:', error.message);\n    } finally {\n      this._isProcessing = false;\n    }\n  }\n\n  /**\n   * Process event with timeout wrapper\n   */\n  async _processWithTimeout(item) {\n    let timeoutHandle;\n    \n    const timeoutPromise = new Promise((_, reject) => {\n      timeoutHandle = setTimeout(\n        () => reject(new Error('Event processing timeout')), \n        this.eventTimeout\n      );\n    });\n    \n    try {\n      const result = await Promise.race([\n        this._processStoredEvent(item),\n        timeoutPromise\n      ]);\n      return result;\n    } finally {\n      // Clear timeout to prevent memory leak\n      if (timeoutHandle) clearTimeout(timeoutHandle);\n    }\n  }\n\n  /**\n   * Process a single stored event from queue\n   */\n  async _processStoredEvent(item) {\n    const { event } = item;\n\n    // Re-check global whitelist (may have changed since enqueue)\n    const whitelist = await this.getAuthorWhitelist();\n    if (whitelist && whitelist.length > 0 && !whitelist.includes(event.pubkey)) {\n      // Throw error to prevent outer ack from overwriting failure status\n      throw new Error('sender_not_allowed');\n    }\n\n    // Decrypt and process (same as immediate mode)\n    await this._processDecryptedEvent(event);\n  }\n\n  /**\n   * Handle received events (entry point)\n   */\n  async _handleEvent(event) {\n    try {\n      // 1. Check if message is for us (p-tag validation)\n      const pTag = event.tags.find(t => t[0] === 'p');\n      if (!pTag || pTag[1] !== this.publicKey) {\n        return;\n      }\n\n      // 2. Global whitelist pre-filter\n      const whitelist = await this.getAuthorWhitelist();\n      if (whitelist && whitelist.length > 0 && !whitelist.includes(event.pubkey)) {\n        console.log(`[SDK] Sender ${event.pubkey.slice(0, 8)} not in whitelist`);\n        return;\n      }\n\n      // 3. Route based on processing mode\n      if (this.processingMode === 'immediate') {\n        await this._processDecryptedEvent(event);\n      } else {\n        // Queued mode: store event for later processing\n        await this._storeEvent(event);\n      }\n    } catch (error) {\n      console.error('Error in _handleEvent:', error.message);\n    }\n  }\n\n  /**\n   * Store event to queue (queued mode only)\n   */\n  async _storeEvent(event) {\n    try {\n      const storageId = await this.eventStorage.enqueue(event);\n      console.log(`[SDK] Event ${event.id?.slice(0, 8)} queued as ${storageId}`);\n    } catch (error) {\n      console.error('Error storing event:', error.message);\n    }\n  }\n\n  /**\n   * Process decrypted event (shared by immediate and queued modes)\n   */\n  async _processDecryptedEvent(event) {\n    try {\n      // Decrypt direct message content\n      const decrypted = await nip04.decrypt(this.privateKey, event.pubkey, event.content);\n\n      // Parse JSON request\n      let request;\n      try {\n        request = JSON.parse(decrypted);\n      } catch (e) {\n        await this._replyError(event.pubkey, 'Invalid JSON format', null);\n        return;\n      }\n\n      // Validate request format\n      if (!request.method) {\n        await this._replyError(event.pubkey, 'Missing method field', null);\n        return;\n      }\n\n      // Get method handler and auth config\n      const methodEntry = this.methodRegistry.get(request.method);\n      if (!methodEntry) {\n        await this._replyError(event.pubkey, `Method not found: ${request.method}`, request.id);\n        return;\n      }\n\n      // Check method-level permissions\n      const hasPermission = await this._checkPermission(request.method, event.pubkey, methodEntry.authConfig);\n      if (!hasPermission) {\n        await this._replyError(event.pubkey, `Permission denied for method: ${request.method}`, request.id);\n        return;\n      }\n\n      // Call handler with enhanced parameters\n      const result = await methodEntry.handler(\n        request.params || {}, \n        event, \n        event.id, \n        event.pubkey\n      );\n\n      // Return result\n      await this._reply(event.pubkey, {\n        id: request.id,\n        result,\n        error: null,\n      });\n    } catch (error) {\n      console.error('Error processing decrypted event:', error.message);\n    }\n  }\n\n  /**\n   * Check method-level permissions\n   */\n  async _checkPermission(methodName, senderPubkey, authConfig) {\n    const { authMode, whitelist, authHandler } = authConfig;\n\n    // Public mode: always allow\n    if (authMode === 'public') {\n      return true;\n    }\n\n    // Whitelist mode: check method-level or global whitelist\n    if (authMode === 'whitelist') {\n      if (whitelist && whitelist.length > 0) {\n        return whitelist.includes(senderPubkey);\n      }\n      // Fallback to global whitelist\n      return await this.isInWhitelist(senderPubkey);\n    }\n\n    // Custom mode: call custom auth handler\n    if (authMode === 'custom' && authHandler) {\n      return await authHandler(senderPubkey);\n    }\n\n    return false;\n  }\n\n  /**\n   * Send direct message reply\n   */\n  async _reply(recipientPubkey, data) {\n    try {\n      const plaintext = JSON.stringify(data);\n      const encrypted = await nip04.encrypt(this.privateKey, recipientPubkey, plaintext);\n\n      const event = {\n        kind: 4,\n        pubkey: this.publicKey,\n        created_at: Math.floor(Date.now() / 1000),\n        tags: [['p', recipientPubkey]],\n        content: encrypted,\n      };\n\n      const signed = finalizeEvent(event, this.privateKey);\n\n      // Use SimplePool to publish to all relays\n      await Promise.any(this.pool.publish(this.relayUrls, signed));\n\n      console.log(`Replied to ${recipientPubkey.slice(0, 8)}`);\n    } catch (error) {\n      console.error('Error sending reply:', error.message);\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Send error reply\n   */\n  async _replyError(recipientPubkey, message, requestId) {\n    await this._reply(recipientPubkey, {\n      id: requestId,\n      result: null,\n      error: message,\n    });\n  }\n\n  /**\n   * Stop listening and cleanup resources\n   */\n  stop() {\n    this.isListening = false;\n\n    // Clear queue processor timer\n    if (this.queueTimer) {\n      clearInterval(this.queueTimer);\n      this.queueTimer = null;\n    }\n\n    // Close subscription\n    if (this.subscription) {\n      this.subscription.close();\n      this.subscription = null;\n    }\n\n    // Close SimplePool\n    this.pool.close(this.relayUrls);\n\n    console.log('SDK stopped');\n    this.emit('stopped');\n  }\n}\n\nexport default NostrSdk;","import NostrClient from './src/nostrClient.js';\nimport NostrSdk from './src/nostrSdk.js';\nimport keyUtils from './src/keyUtils.js';\n\nimport * as nip04 from 'nostr-tools/nip04';\nimport * as nip19 from 'nostr-tools/nip19';\nimport { SimplePool, useWebSocketImplementation } from 'nostr-tools/pool';\nimport {\n  finalizeEvent,\n  verifyEvent,\n  generateSecretKey,\n  getPublicKey,\n} from 'nostr-tools/pure';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\n\nconst api = {\n  NostrClient,\n  NostrSdk,\n  nip04,\n  nip19,\n  SimplePool,\n  useWebSocketImplementation,\n  finalizeEvent,\n  verifyEvent,\n  generateSecretKey,\n  getPublicKey,\n  bytesToHex,\n  hexToBytes,\n  keyUtils,\n};\n\nexport {\n  NostrClient,\n  NostrSdk,\n  nip04,\n  nip19,\n  SimplePool,\n  useWebSocketImplementation,\n  finalizeEvent,\n  verifyEvent,\n  generateSecretKey,\n  getPublicKey,\n  bytesToHex,\n  hexToBytes,\n  keyUtils,\n};\n\nexport default api;\n"],"names":["isNsecKey","value","isNpubKey","decodeNsecToBytes","nsecKey","nip19","normalizeSecretKey","secret","isHex64","hexToBytes","secretToHex","bytes","bytesToHex","encodeSecretToNsec","derivePubkeyFromSecret","getPublicKey","decodeNpubToHex","npubKey","encodePubkeyToNpub","pubkey","hex","publicToHex","keyUtils","NostrClient","options","SimplePool","tags","builder","baseFilter","context","draft","result","method","params","resolve","reject","requestId","request","subscription","timeoutId","settled","cleanup","finalize","error","plaintext","encrypted","nip04","event","signed","finalizeEvent","filter","replyEvent","pTag","t","decrypted","response","err","text","recipientPubkey","waitForReply","recipientPubkeyHex","sentEventId","sentTimestamp","eTag","senderPubkey","onMessage","onError","senderPubkeyHex","createMemoryQueue","queue","idCounter","storageId","limit","meta","NostrSdk","EventEmitter","handler","authConfig","pubkeys","normalized","pk","whitelist","intervalMs","batchSize","items","results","item","i","_a","timeoutHandle","timeoutPromise","_","methodEntry","methodName","authMode","authHandler","data","message","api","useWebSocketImplementation","verifyEvent","generateSecretKey"],"mappings":"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"}